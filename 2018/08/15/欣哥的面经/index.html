<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="面经," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="欣哥的面经…  在公司实习的时候一直都是在使用Kubernetes和docker，但是对其中的一些原理性的概念都是不明白的，面试的时候别人问的恰恰都是这些原理性的东西，所以问欣哥面容器相关的岗位一般都会考一些什么问题。">
<meta name="keywords" content="面经">
<meta property="og:type" content="article">
<meta property="og:title" content="欣哥的面经...">
<meta property="og:url" content="http://fennudehaogua.top/2018/08/15/欣哥的面经/index.html">
<meta property="og:site_name" content="fennudehaogua.top">
<meta property="og:description" content="欣哥的面经…  在公司实习的时候一直都是在使用Kubernetes和docker，但是对其中的一些原理性的概念都是不明白的，面试的时候别人问的恰恰都是这些原理性的东西，所以问欣哥面容器相关的岗位一般都会考一些什么问题。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/fennudehaogua/hexopictures/master/k8s.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fennudehaogua/hexopictures/master/gaokeyong.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fennudehaogua/hexopictures/master/resources.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fennudehaogua/hexopictures/master/work.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fennudehaogua/hexopictures/master/calico_jiagou.png">
<meta property="og:image" content="https://raw.githubusercontent.com/fennudehaogua/hexopictures/master/calico_yuanli.png">
<meta property="og:updated_time" content="2018-08-16T02:21:24.559Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="欣哥的面经...">
<meta name="twitter:description" content="欣哥的面经…  在公司实习的时候一直都是在使用Kubernetes和docker，但是对其中的一些原理性的概念都是不明白的，面试的时候别人问的恰恰都是这些原理性的东西，所以问欣哥面容器相关的岗位一般都会考一些什么问题。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/fennudehaogua/hexopictures/master/k8s.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://fennudehaogua.top/2018/08/15/欣哥的面经/"/>





  <title>欣哥的面经... | fennudehaogua.top</title>
  














    <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    <a href="https://github.com/fennudehaogua"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fennudehaogua.top</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">生而为人，我很抱歉。————不装逼，不存在的。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fennudehaogua.top/2018/08/15/欣哥的面经/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wu Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jiansheng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fennudehaogua.top">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">欣哥的面经...</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-15T22:12:34+08:00">
                2018-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="欣哥的面经…"><a href="#欣哥的面经…" class="headerlink" title="欣哥的面经…"></a>欣哥的面经…</h2><p>  在公司实习的时候一直都是在使用Kubernetes和docker，但是对其中的一些原理性的概念都是不明白的，面试的时候别人问的恰恰都是这些原理性的东西，所以问欣哥面容器相关的岗位一般都会考一些什么问题。<br><a id="more"></a> </p>
<h3 id="1-介绍一下k8s的基本架构"><a href="#1-介绍一下k8s的基本架构" class="headerlink" title="1. 介绍一下k8s的基本架构"></a><strong>1. 介绍一下k8s的基本架构</strong></h3><p><img src="https://raw.githubusercontent.com/fennudehaogua/hexopictures/master/k8s.png" alt="K8s"></p>
<p><strong>Master</strong>：</p>
<p><strong>1、API Server[资源操作入口]</strong><br>  ● 提供了资源对象的唯一操作入口，其他所有组件都必须通过它提供的API来操作资源数据，只有API Server与存储通信，其他模块通过API Server访问集群状态。<br>第一，是为了保证集群状态访问的安全。<br>第二，是为了隔离集群状态访问的方式和后端存储实现的方式：API Server是状态访问的方式，不会因为后端存储技术etcd的改变而改变。<br>  ● 作为kubernetes系统的入口，封装了核心对象的增删改查操作，以RESTFul接口方式提供给外部客户和内部组件调用。对相关的资源数据“全量查询”+“变化监听”，实时完成相关的业务功能。</p>
<p><strong>2、Controller Manager[内部管理控制中心]</strong><br>  ● 实现集群故障检测和恢复的自动化工作，负责执行各种控制器，主要有：<br>endpoint-controller：定期关联service和pod(关联信息由endpoint对象维护)，保证service到pod的映射总是最新的。<br>replication-controller：定期关联replicationController和pod，保证replicationController定义的复制数量与实际运行pod的数量总是一致的。  </p>
<p><strong>3、Scheduler[集群分发调度器]</strong><br>  ● Scheduler收集和分析当前Kubernetes集群中所有Node节点的资源(内存、CPU)负载情况，然后依此分发新建的Pod到Kubernetes集群中可用的节点。<br>  ● 实时监测Kubernetes集群中未分发和已分发的所有运行的Pod。<br>  ● Scheduler也监测Node节点信息，由于会频繁查找Node节点，Scheduler会缓存一份最新的信息在本地。<br>  ● 最后，Scheduler在分发Pod到指定的Node节点后，会把Pod相关的信息Binding写回API Server。  </p>
<p><strong>Node：</strong></p>
<p><strong>1、Kubelet[节点上的Pod管家]</strong><br>  ● 负责Node节点上pod的创建、修改、监控、删除等全生命周期的管理<br>  ● 定时上报本Node的状态信息给API Server。<br>  ● kubelet是Master API Server和Node之间的桥梁，接收Master   API Server分配给它的commands和work，与持久性键值存储etcd、file、server和http进行交互，读取配置信息。<br>  ● 具体的工作如下：<br>设置容器的环境变量、给容器绑定Volume、给容器绑定Port、根据指定的Pod运行一个单一容器、给指定的Pod创建network 容器。<br>同步Pod的状态、同步Pod的状态、从cAdvisor获取Container info、 pod info、 root info、 machine info。<br>在容器中运行命令、杀死容器、删除Pod的所有容器。  </p>
<p><strong>2、Proxy[负载均衡、路由转发]</strong> </p>
<p>● Proxy是为了解决外部网络能够访问跨机器集群中容器提供的应用服务而设计的，运行在每个Node上。<br>Proxy提供TCP/UDP sockets的proxy，每创建一种Service，Proxy主要从etcd获取Services和Endpoints的配置信息（也可以从file获取），然后根据配置信息在Node上启动一个Proxy的进程并监听相应的服务端口，当外部请求发生时，Proxy会根据Load Balancer将请求分发到后端正确的容器处理。<br>● Proxy不但解决了同一主宿机相同服务端口冲突的问题，还提供了Service转发服务端口对外提供服务的能力，Proxy后端使用了随机、轮循负载均衡算法。  </p>
<p><strong>3、kubectl（kubelet client）[集群管理命令行工具集]</strong><br>通过客户端的kubectl命令集操作，API Server响应对应的命令结果，从而达到对kubernetes集群的管理。  </p>
<h3 id="2-如何实现docker容器-需要用到哪些技术"><a href="#2-如何实现docker容器-需要用到哪些技术" class="headerlink" title="2. 如何实现docker容器 需要用到哪些技术"></a><strong>2. 如何实现docker容器 需要用到哪些技术</strong></h3><p><strong>cgroup 和 namespace 是最重要的两种技术。cgroup 实现资源限额， namespace 实现资源隔离。</strong><br><strong>1.cgroup</strong><br>全称 Control Group。Linux 操作系统通过 cgroup 可以设置进程使用 CPU、内存 和 IO 资源的限额。–cpu-shares、-m、–device-write-bps 实际上就是在配置 cgroup<br><strong>2.namespaces</strong><br>在每个容器中，我们都可以看到文件系统，网卡等资源，这些资源看上去是容器自己的。拿网卡来说，每个容器都会认为自己有一块独立的网卡，即使 host 上只有一块物理网卡。这种方式非常好，它使得容器更像一个独立的计算机。<br>Linux 实现这种方式的技术是 namespace。namespace 管理着 host 中全局唯一的资源，并可以让每个容器都觉得只有自己在使用它。换句话说，namespace 实现了容器间资源的隔离。</p>
<p>Linux 使用了六种 namespace，分别对应六种资源：Mount、UTS、IPC、PID、Network 和 User，下面我们分别讨论。 </p>
<p><strong>Mount namespace</strong><br>Mount namespace 让容器看上去拥有整个文件系统。<br>容器有自己的 / 目录，可以执行 mount 和 umount 命令。当然我们知道这些操作只在当前容器中生效，不会影响到 host 和其他容器。</p>
<p><strong>UTS namespace</strong><br>简单的说，UTS namespace 让容器有自己的 hostname。 默认情况下，容器的 hostname 是它的短ID，可以通过 -h 或 –hostname 参数设置。  </p>
<p><strong>IPC namespace</strong><br>IPC namespace 让容器拥有自己的共享内存和信号量（semaphore）来实现进程间通信，而不会与 host 和其他容器的 IPC 混在一起。</p>
<p><strong>PID namespace</strong><br>我们前面提到过，容器在 host 中以进程的形式运行。而且进程的 PID 不同于 host 中对应进程的 PID，容器中 PID=1 的进程当然也不是 host 的 init 进程。也就是说：容器拥有自己独立的一套 PID，这就是 PID namespace 提供的功能。</p>
<p><strong>Network namespace</strong><br>Network namespace 让容器拥有自己独立的网卡、IP、路由等资源。<br><strong>User namespace</strong><br>User namespace 让容器能够管理自己的用户，host 不能看到容器中创建的用户。    </p>
<h3 id="3-k8s的高可用怎么做"><a href="#3-k8s的高可用怎么做" class="headerlink" title="3. k8s的高可用怎么做"></a><strong>3. k8s的高可用怎么做</strong></h3><p>为了实现没有单点故障的目标，需要为以下几个组件建立高可用方案：<br>  ● etcd<br>  ● kube-apiserver<br>  ● kube-controller-manager与kube-scheduler<br>  ● kube-dns<br>这些组件的关系可参考下面这张集群架构示意图。<br><img src="https://raw.githubusercontent.com/fennudehaogua/hexopictures/master/gaokeyong.png" alt="gaokeyong"><br>下面为大家逐个详细介绍各个组件的高可用策略。  </p>
<p><strong>etcd高可用</strong><br>etcd是Kubernetes当中唯一带状态的服务，也是高可用的难点。<br>Kubernetes选用etcd作为它的后端数据存储仓库正是看重了其使用分布式架构，没有单点故障的特性。<br>虽然单节点的etcd也可以正常运行。但是推荐的部署方案均是采用3个或者5个节点组成etcd集群，供Kubernetes使用。<br>大家常使用的kubeadm工具默认是在一个单节点上启动etcd以及所有的Master组件。虽然使用起来非常方便，但是要用到生产环境还是要注意这个节点当机的风险。   </p>
<p>etcd的高可用基本有三种思路：<br>一是使用<strong>独立的etcd集群</strong>，使用3台或者5台服务器只运行etcd，独立维护和升级。甚至可以使用CoreOS的update-engine和locksmith，让服务器完全自主的完成升级。这个etcd集群将作为基石用于构建整个集群。 采用这项策略的主要动机是etcd集群的节点增减都需要显式的通知集群，保证etcd集群节点稳定可以更方便的用程序完成集群滚动升级，减轻维护负担。  </p>
<p>二是在Kubernetes Master上用<strong>static pod的形式来运行etcd</strong>，并将多台Kubernetes Master上的etcd组成集群。 在这一模式下，各个服务器的etcd实例被注册进了Kubernetes当中，虽然无法直接使用kubectl来管理这部分实例，但是监控以及日志搜集组件均可正常工作。在这一模式运行下的etcd可管理性更强。</p>
<p>三是使用CoreOS提出的<strong>self-hosted etcd</strong>方案，将本应在底层为Kubernetes提供服务的etcd运行在Kubernetes之上。 实现Kubernetes对自身依赖组件的管理。在这一模式下的etcd集群可以直接使用etcd-operator来自动化运维，最符合Kubernetes的使用习惯。<br>这三种思路均可以实现etcd高可用的目标，但是在选择过程中却要根据实际情况做出一些判断。简单来讲预算充足但保守的项目选方案一， 想一步到位并愿意承担一定风险的项目选方案三。折中一点选方案二。各个方案的优劣以及做选择过程中的取舍在这里就不详细展开了，对这块有疑问的朋友可以私下联系交流。  </p>
<p><strong>kube-apiserver高可用</strong><br>apiserver本身是一个无状态服务，要实现其高可用相对要容易一些，难点在于如何将运行在多台服务器上的apiserver用一个统一的外部入口暴露给所有Node节点。<br>apiserver的高可用也有三种基本思路：<br>一是使用<strong>外部负载均衡器</strong>，不管是使用公有云提供的负载均衡器服务或是在私有云中使用LVS或者HaProxy自建负载均衡器都可以归到这一类。 负载均衡器是非常成熟的方案，在这里略过不做过多介绍。如何保证负载均衡器的高可用，则是选择这一方案需要考虑的新问题。   </p>
<p>二是在<strong>网络层做负载均衡</strong>。比如在Master节点上用BGP做ECMP，或者在Node节点上用iptables做NAT都可以实现。采用这一方案不需要额外的外部服务，但是对网络配置有一定的要求。 </p>
<p>三是<strong>在Node节点上使用反向代理对多个Master做负载均衡</strong>。这一方案同样不需要依赖外部的组件，但是当Master节点有增减时，如何动态配置Node节点上的负载均衡器成为了另外一个需要解决的问题。<br>从目前各个集群管理工具的选择来看，这三种模式都有被使用，目前还没有明确的推荐方案产生。建议在公有云上的集群多考虑第一种模式，在私有云环境中由于维护额外的负载均衡器也是一项负担，建议考虑第二种或是第三种方案。  </p>
<p><strong>kube-controller-manager与kube-scheduler高可用</strong><br>这两项服务是Master节点的一部分，他们的高可用相对容易，仅需要运行多份实例即可。但是这两个核心组件会修改集群的状态信息，所以需要选举出lead，以保证同一时间只有一个是实例可以对集群的状态信息进行读写(通过在kube-controller-manager与kube-scheduler的每个实例的启动参数中设置–leader-elect=true)。这些实例会通过向apiserver中的Endpoint加锁（租赁锁）的方式来进行leader election， 当目前拿到leader的实例无法正常工作时，别的实例会拿到锁，变为新的leader。<br>目前在多个Master节点上采用static pod模式部署这两项服务的方案比较常见，激进一点也可以采用self-hosted的模式，在Kubernetes之上用DaemonSet或者Deployment来部署。    </p>
<p><strong>Kube-dns高可用</strong><br>严格来说kube-dns并不算是Master组件的一部分，因为它是可以跑在Node节点上，并用Service向集群内部提供服务的。但在实际环境中， 由于默认配置只运行了一份kube-dns实例，在其升级或是所在节点当机时，会出现集群内部dns服务不可用的情况，严重时会影响到线上服务的正常运行。<br>为了避免故障，请将kube-dns的replicas值设为2或者更多，并用anti-affinity将他们部署在不同的Node节点上。这项操作比较容易被疏忽，直到出现故障时才发现原来是kube-dns只运行了一份实例导致的故障。  </p>
<p><strong>总结</strong><br>上面介绍了Kubernetes Master各个组件高可用可以采用的策略。其中etcd和kube-apiserver的高可用是整个方案的重点。由于存在多种高可用方案，集群管理员应当根据集群所处环境以及其他限制条件选择适合的方案。<br>在实际建设过程中，在完成了上述四个组件的高可用之后，最好采取实际关机检验的方式来验证高可用方案的可靠性，并根据检验的结果不断调整和优化整个方案。<br>此外将高可用方案与系统自动化升级方案结合在一起考虑，实现高可用下的系统自动升级，将大大减轻集群的日常运维负担，值得投入精力去研究。  </p>
<h3 id="5-Deployment的rollingupdate是怎么实现的"><a href="#5-Deployment的rollingupdate是怎么实现的" class="headerlink" title="5. Deployment的rollingupdate是怎么实现的"></a><strong>5. Deployment的rollingupdate是怎么实现的</strong></h3><p>rollingupdate，可以使得服务近乎无缝地平滑升级，即在不停止对外服务的前提下完成应用的更新。<br>1.重点关注的三个参数<br><strong>.spec.minReadySeconds</strong>：<br> 新创建的Pod状态为Ready持续的时间至少为.spec.minReadySeconds才认为Pod Available(Ready)。<br><strong>.spec.strategy.rollingUpdate.maxSurge</strong>,：<br>表示滚动升级时会先启动.spec.strategy.rollingUpdate.maxSurge个pod。<br>可以为整数或者百分比，默认为desired Pods数的25%. Scale Up新的ReplicaSet时，按照比例计算出允许的MaxSurge，计算时向上取整(比如3.4，取4)。<br><strong>.spec.strategy.rollingUpdate. maxUnavailable</strong>：<br>表示滚动升级时允许的最大Unavailable的pod个数。<br>可以为整数或者百分比，默认为desired Pods数的25%. Scale Down旧的ReplicaSet时，按照比例计算出允许的maxUnavailable，计算时向下取整(比如3.6，取3)。  </p>
<p>因此，在Deployment rollout时，需要保证Available(Ready) Pods数<br>不低于 desired pods number - maxUnavailable;<br>保证所有的Pods数不多于 desired pods number + maxSurge。  </p>
<p>kubectl set image <strong>*</strong> –record<br>set image之后，导致Deployment’s Pod Template发生变化，就会触发rollout。通过kubectl get rs -w来watch ReplicaSet的变化。  </p>
<p>desired replicas：期望最后Ready的pod个数<br>1.NewRS创建maxSurge个Pods，这时达到pods数的上限值desired replicas + maxSurge     </p>
<p>2.不会等NewRS创建的Pods Ready，而是马上delete OldRS maxUnavailable个Pods，这时Ready的Pods number最差也能保证desired replicas - maxUnavailable   </p>
<p>3.接下来的流程是不固定，只要新建的Pods有几个返回Ready，则意味着可以接着删除几个旧的Pods了。只要有几个删除成功的Pods返回，就会创建一定数量的Pods，只要All pods数量与上限值desired replicas + maxSurge有差值空间，就会接着创建新的Pods。  </p>
<p>4.如此进行滚动更新， 直到创建的新Pods个数达到desired replicas，并等待它们都Ready，然后再删除所有剩余的旧的Pods。至此，滚动流程结束。  </p>
<h3 id="6-RC和RS的区别"><a href="#6-RC和RS的区别" class="headerlink" title="6. RC和RS的区别"></a><strong>6. RC和RS的区别</strong></h3><p>1.RC只支持基于等式的selector，如env=dev或者environment!=qa。但在RS中，还支持新的基于集合的selector，如version in (v1.0,v2.0)或者env not in (dev,qa)。这给复杂的运维管理带来方便<br>2.升级方式<br>RS不能使用kubectlrollingupdate进行升级，kubectl   rollingupdate专用于rc<br>RS升级使用deployment或者kubectl replace命令<br>使用Deployment升级Pod只需要定义Pod的最终状态，k8s会为你执行必要的操作，虽然能够使用命令kubectl rolling-update完成升级，但它是在客户端与服务端多次交互控制RC完成的，所以REST API中并没有rolling-update的接口，这为定制自己的管理系统带来了一些麻烦。<br>3.Deployment拥有更加灵活强大的升级、回滚功能  </p>
<p><strong>Replication controller</strong>：部署、升级Pod<br>应用托管到Kubernetes之后，需要保证应用能够持续的运行，Replication Controller就是这个保证，主要的功能如下：<br>  ● 确保pod数量：它会确保Kubernetes中有指定数量的Pod在运行。如果少于指定数量的pod，Replication Controller会创建新的，反之则会删除掉多余的以保证Pod数量不变。<br>  ● 确保pod健康：当pod不健康，运行出错或者无法提供服务时，Replication Controller也会杀死不健康的pod，重新创建新的。<br>  ● 弹性伸缩 ：在业务高峰或者低峰期的时候，可以通过Replication Controller动态的调整pod的数量来提高资源的利用率。同时，配置相应的监控功能（Hroizontal Pod Autoscaler），会定时自动从监控平台获取Replication Controller关联pod的整体资源使用情况，做到自动伸缩。<br>  ● 滚动升级：滚动升级为一种平滑的升级方式，通过逐步替换的策略，保证整体系统的稳定，在初始化升级的时候就可以及时发现和解决问题，避免问题不断扩大。  </p>
<p><strong>Replica set</strong>：下一代Replication Controller<br>被认为 是“升级版”的RC。RS也是用于保证与label selector匹配的pod数量维持在期望状态。Replica Set目前与RC的区别只是支持的selector不同，后续肯定会加入更多功能。  </p>
<p><strong>Deployment</strong>：更加方便的管理Pod和Replica Set<br>Deployment同样为Kubernetes的一个核心内容，主要职责同样是为了保证pod的数量和健康，90%的功能与Replication Controller完全一样，可以看做新一代的Replication Controller。但是，它又具备了Replication Controller之外的新特性：<br>  ● Replication Controller全部功能：Deployment继承了上面描述的Replication Controller全部功能。<br>  ● 事件和状态查看：可以查看Deployment的升级详细进度和状态。<br>  ● 回滚：当升级pod镜像或者相关参数的时候发现问题，可以使用回滚操作回滚到上一个稳定的版本或者指定的版本。<br>  ● 版本记录: 每一次对Deployment的操作，都能保存下来，给予后续可能的回滚使用。<br>  ● 暂停和启动：对于每一次升级，都能够随时暂停和启动。<br>  ● 多种升级方案：Recreate：删除所有已存在的pod,重新创建新的; RollingUpdate：滚动升级，逐步替换的策略，同时滚动升级时，支持更多的附加参数，例如设置最大不可用pod数量，最小升级间隔时间等等。  </p>
<h3 id="7-介绍一下对crd和api聚合的理解"><a href="#7-介绍一下对crd和api聚合的理解" class="headerlink" title="7. 介绍一下对crd和api聚合的理解"></a><strong>7. 介绍一下对crd和api聚合的理解</strong></h3><p><strong>CRD（扩展资源）</strong>：<br>Kubernetes平台对于分布式服务部署的很多重要的模块都有系统性的支持，借助如下一些平台资源可以满足大多数分布式系统部署和管理的需求：<br><img src="https://raw.githubusercontent.com/fennudehaogua/hexopictures/master/resources.png" alt="resources"></p>
<p>但是在不同应用业务环境下，对于平台可能有一些特殊的需求，这些需求可以抽象为Kubernetes的扩展资源，而Kubernetes的CRD  (CustomResourceDefinition)为这样的需求提供了轻量级的机制，保证新的资源的快速注册和使用。在更老的版本中，TPR(ThirdPartyResource)是与CRD类似的概念，但是在1.9以上的版本中被弃用，而CRD则进入的beta状态。  </p>
<p><strong>CRD的工作步骤如下</strong>：<br>用户向Kubernetes API服务注册一个带特定schema的资源，并定义相关API<br>  ● 注册一系列该资源的实例<br>  ● 在Kubernetes的其它资源对象中引用这个新注册资源的对象实例<br>  ● 用户自定义的controller例程需要对这个引用进行释义和实施，让新的资源对象达到预期的状态<br>从基本原理上来讲，CRD定义的Kubernetes扩展资源：<br>  ● 借助Kubernetes RBAC和authentication机制来保证该扩展资源的security、access control、authentication和multitenancy。<br>  ● 将扩展资源的数据存储到Kubernetes的etcd集群<br>  ● 借助Kubernetes提供的controller模式开发框架，实现新的  controller，并借助APIServer监听etcd集群关于该资源的状态并定义状态变化的处理逻辑  </p>
<p><strong>api聚合（Aggregated API）：</strong><br>kubernetes的 Aggregated API是什么呢？它是允许k8s的开发人员编写一个自己的服务，可以把这个服务注册到k8s的api里面，这样，就像k8s自己的api一样，你的服务只要运行在k8s集群里面，k8s 的Aggregate通过service名称就可以转发到你写的service里面去了。<br>这个设计理念：<br>第一是增加了api的扩展性，这样k8s的开发人员就可以编写自己的API服务器来公开他们想要的API。集群管理员应该能够使用这些服务，而不需要对核心库存储库进行任何更改。<br>第二是丰富了APIs，核心kubernetes团队阻止了很多新的API提案。通过允许开发人员将他们的API作为单独的服务器公开，并使集群管理员能够在不对核心库存储库进行任何更改的情况下使用它们，这样就无须社区繁杂的审查了<br>第三是开发分阶段实验性API的地方，新的API可以在单独的聚集服务器中开发，当它稳定之后，那么把它们封装起来安装到其他集群就很容易了。<br>第四是确保新API遵循kubernetes约定：如果没有这里提出的机制，社区成员可能会被迫推出自己的东西，这可能会或可能不遵循kubernetes约定。  </p>
<p>一句话阐述就是：<br>Aggregator for Kubernetes-style API servers:<br>dynamic registration, discovery summarization, secure proxy<br>动态注册、发现汇总、和安全代理。  </p>
<h3 id="8-介绍pod和ReplicaSet创建时，k8s的各个组件如何协同工作的"><a href="#8-介绍pod和ReplicaSet创建时，k8s的各个组件如何协同工作的" class="headerlink" title="8. 介绍pod和ReplicaSet创建时，k8s的各个组件如何协同工作的"></a><strong>8. 介绍pod和ReplicaSet创建时，k8s的各个组件如何协同工作的</strong></h3><p>创建pod：<br><img src="https://raw.githubusercontent.com/fennudehaogua/hexopictures/master/work.png" alt="pod"></p>
<p>具体的创建步骤包括：<br>1、客户端提交创建请求，可以通过API Server的Restful API，也可以使用kubectl命令行工具。支持的数据类型包括JSON和YAML。<br>2、API Server处理用户请求，存储Pod数据到etcd。<br>3、调度器通过API Server查看未绑定的Pod。尝试为Pod分配主机。<br>4、过滤主机 (调度预选)：调度器用一组规则过滤掉不符合要求的主机。比如Pod指定了所需要的资源量，那么可用资源比Pod需要的资源量少的主机会被过滤掉。<br>5、主机打分(调度优选)：对第一步筛选出的符合要求的主机进行打分，在主机打分阶段，调度器会考虑一些整体优化策略，比如把容一个Replication Controller的副本分布到不同的主机上，使用最低负载的主机等。<br>6、选择主机：选择打分最高的主机，进行binding操作，结果存储到etcd中。<br>7、kubelet根据调度结果执行Pod创建操作： 绑定成功后，scheduler会调用APIServer的API在etcd中创建一个boundpod对象，描述在一个工作节点上绑定运行的所有pod信息。运行在每个工作节点上的kubelet也会定期与etcd同步boundpod信息，一旦发现应该在该工作节点上运行的boundpod对象没有更新，则调用Docker API创建并启动pod内的容器。  </p>
<h3 id="9-Dockerfile中的ADD和COPY有什么区别"><a href="#9-Dockerfile中的ADD和COPY有什么区别" class="headerlink" title="9. Dockerfile中的ADD和COPY有什么区别"></a><strong>9. Dockerfile中的ADD和COPY有什么区别</strong></h3><p>COPY 复制文件<br>格式：<br>  ● COPY &lt;源路径&gt;… &lt;目标路径&gt;<br>  ● COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]<br>COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如：<br>COPY package.json /usr/src/app/  </p>
<p>&lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：<br>COPY hom* /mydir/<br>COPY hom?.txt /mydir/  </p>
<p>&lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。<br>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。  </p>
<p><strong>ADD 更高级的复制文件</strong><br>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。<br>比如 &lt;源路径&gt; 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。<br>如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。<br>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中：<br>FROM scratch<br>ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /<br>…  </p>
<p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。<br>在 Docker 官方的最佳实践文档中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。<br>另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。<br>因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。  </p>
<h3 id="10-Calico的架构"><a href="#10-Calico的架构" class="headerlink" title="10. Calico的架构"></a><strong>10. Calico的架构</strong></h3><p><img src="https://raw.githubusercontent.com/fennudehaogua/hexopictures/master/calico_jiagou.png" alt="calico_jiagou"></p>
<p><strong>calico包括如下重要组件：Felix，etcd，BGP Client，BGP Route Reflector。</strong>下面分别说明一下这些组件。<br>Felix：主要负责路由配置以及ACLS规则的配置以及下发，它存在在每个node节点上。<br>etcd：分布式键值存储，主要负责网络元数据一致性，确保Calico网络状态的准确性，可以与kubernetes共用；<br>BGPClient(BIRD), 主要负责把 Felix写入 kernel的路由信息分发到当前 Calico网络，确保 workload间的通信的有效性；<br>BGPRoute Reflector(BIRD), 大规模部署时使用，摒弃所有节点互联的mesh模式，通过一个或者多个 BGPRoute Reflector 来完成集中式的路由分发；  </p>
<p><strong>calico原理</strong><br>如下图所示，描述了从源容器经过源宿主机，经过数据中心的路由，然后到达目的宿主机最后分配到目的容器的过程。<br><img src="https://raw.githubusercontent.com/fennudehaogua/hexopictures/master/calico_yuanli.png" alt="calico_yuanli"></p>
<p>整个过程中始终都是根据iptables规则进行路由转发，并没有进行封包，解包的过程，这和flannel比起来效率就会快多了。  </p>
<h3 id="14-如何实现容器的跨主机网络通信"><a href="#14-如何实现容器的跨主机网络通信" class="headerlink" title="14.如何实现容器的跨主机网络通信"></a><strong>14.如何实现容器的跨主机网络通信</strong></h3><p>早期大家的跨主机通信方案主要有以下几种：<br>  ● 容器使用host模式：容器直接使用宿主机的网络，这样天生就可以支持跨主机通信。虽然可以解决跨主机通信问题，但这种方式应用场景很有限，容易出现端口冲突，也无法做到隔离网络环境，一个容器崩溃很可能引起整个宿主机的崩溃。<br>  ● 端口绑定：通过绑定容器端口到宿主机端口，跨主机通信时，使用主机IP+端口的方式访问容器中的服务。显而易见，这种方式仅能支持网络栈的四层及以上的应用，并且容器与宿主机紧耦合，很难灵活的处理，可扩展性不佳。<br>  ● docker外定制容器网络：在容器通过docker创建完成后，然后再通过修改容器的网络命名空间来定义容器网络。典型的就是很久以前的pipework，容器以none模式创建，pipework通过进入容器的网络命名空间为容器重新配置网络，这样容器网络可以是静态IP、vxlan网络等各种方式，非常灵活，容器启动的一段时间内会没有IP，明显无法在大规模场景下使用，只能在实验室中测试使用。<br>  ● 第三方SDN定义容器网络：使用Open vSwitch或Flannel等第三方SDN工具，为容器构建可以跨主机通信的网络环境。这些方案一般要求各个主机上的docker0网桥的cidr不同，以避免出现IP冲突的问题，限制了容器在宿主机上的可获取IP范围。并且在容器需要对集群外提供服务时，需要比较复杂的配置，对部署实施人员的网络技能要求比较高。<br>上面这些方案有各种各样的缺陷，同时也因为跨主机通信的迫切需求，docker 1.9版本时，官方提出了基于vxlan的overlay网络实现，原生支持容器的跨主机通信。同时，还支持通过libnetwork的plugin机制扩展各种第三方实现，从而以不同的方式实现跨主机通信。就目前社区比较流行的方案来说，跨主机通信的基本实现方案有以下几种：<br>  ● 基于隧道的overlay网络：按隧道类型来说，不同的公司或者组织有不同的实现方案。docker原生的overlay网络就是基于vxlan隧道实现的。ovn则需要通过geneve或者stt隧道来实现的。flannel最新版本也开始默认基于vxlan实现overlay网络。<br>  ● 基于包封装的overlay网络：基于UDP封装等数据包包装方式，在docker集群上实现跨主机网络。典型实现方案有weave、flannel的早期版本。<br>  ● 基于三层实现SDN网络：基于三层协议和路由，直接在三层上实现跨主机网络，并且通过iptables实现网络的安全隔离。典型的方案为Project Calico。同时对不支持三层路由的环境，Project Calico还提供了基于IPIP封装的跨主机网络实现。  </p>
<p><strong>遗留问题：</strong><br><strong>4. 介绍一下你做过的容器项目 并且重点介绍你负责的部分</strong>  </p>
<p><strong>8. 介绍pod和ReplicaSet创建时，k8s的各个组件如何协同工作的</strong> </p>
<p><strong>11. 如何解决大规模使用镜像时引起的Harbor变慢变卡问题</strong></p>
<p><strong>12. 在生产环境使用k8s集群 需要额外做哪些工作</strong></p>
<p><strong>13. 看过k8s源码吗 都看过哪些 介绍一下</strong></p>
<p><strong>15. 谈谈你对k8s存储的理解</strong></p>
<p>还有一定会问你们大学的数据结构 甚至让你们用擅长的语言编程 因为你们刚毕业<br>我遇到的还记得的问题大概就这些 你们看情况酌情学习 因为我面试的是高级 你们面试可能会问不一样的问题<br>但是数据结构 还有k8s架构和各个组件如何协同工作的 九成以上会问你们<br>再在k8s的周边领域选择一个你们擅长的领域 做为你们实习期主要负责的部分重点准备一下 面试官可能会进一步问你们</p>

      
    </div>
    
    
    

    

      <div>
        
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
        
      </div>

      
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面经/" rel="tag"><i class="fa fa-tag"></i> 面经</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/14/test-1/" rel="next" title="test_1">
                <i class="fa fa-chevron-left"></i> test_1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  <div onclick="showGitment()" id="gitment_title" class="gitment_title">显示 Gitment 评论</div>
  <div id="container" style="display:none"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
  const myTheme = {
  render(state, instance) {
  const container = document.createElement('div');
  container.lang = "en-US";
    container.className = 'gitment-container gitment-root-container';
   container.appendChild(instance.renderHeader(state, instance));
    container.appendChild(instance.renderEditor(state, instance));
    container.appendChild(instance.renderComments(state, instance));
    container.appendChild(instance.renderFooter(state, instance));
    return container;
    }
}
function showGitment() {
$("#gitment_title").attr("style", "display:none");
$("#container").attr("style", "").addClass("gitment_container");
var gitment = new Gitment({
id: window.location.pathname,
theme: myTheme,
owner: '',
repo: '',
oauth: {
client_id: '9f634ff1d663061b7b31',
client_secret: '45166540e0b361ee1919e27f29ad9aac978d8437'
}
});
gitment.render('container');
}
</script>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/jiansheng.jpg"
               alt="Wu Tian" />
          <p class="site-author-name" itemprop="name">Wu Tian</p>
           
              <p class="site-description motion-element" itemprop="description">Record</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fennudehaogua" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://mail.google.com/mail/u/0/?tab=wm#inbox" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://plus.google.com/u/0/102058793050907796987" target="_blank" title="Google">
                  
                    <i class="fa fa-fw fa-google"></i>
                  
                    
                      Google
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/3270404320/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://cheneydc.me/" title="聪哥大佬的博客" target="_blank">聪哥大佬的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://xiaopijie.top/" title="xiaopijie.top" target="_blank">xiaopijie.top</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#欣哥的面经…"><span class="nav-number">1.</span> <span class="nav-text">欣哥的面经…</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-介绍一下k8s的基本架构"><span class="nav-number">1.1.</span> <span class="nav-text">1. 介绍一下k8s的基本架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-如何实现docker容器-需要用到哪些技术"><span class="nav-number">1.2.</span> <span class="nav-text">2. 如何实现docker容器 需要用到哪些技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-k8s的高可用怎么做"><span class="nav-number">1.3.</span> <span class="nav-text">3. k8s的高可用怎么做</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Deployment的rollingupdate是怎么实现的"><span class="nav-number">1.4.</span> <span class="nav-text">5. Deployment的rollingupdate是怎么实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-RC和RS的区别"><span class="nav-number">1.5.</span> <span class="nav-text">6. RC和RS的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-介绍一下对crd和api聚合的理解"><span class="nav-number">1.6.</span> <span class="nav-text">7. 介绍一下对crd和api聚合的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-介绍pod和ReplicaSet创建时，k8s的各个组件如何协同工作的"><span class="nav-number">1.7.</span> <span class="nav-text">8. 介绍pod和ReplicaSet创建时，k8s的各个组件如何协同工作的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Dockerfile中的ADD和COPY有什么区别"><span class="nav-number">1.8.</span> <span class="nav-text">9. Dockerfile中的ADD和COPY有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Calico的架构"><span class="nav-number">1.9.</span> <span class="nav-text">10. Calico的架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-如何实现容器的跨主机网络通信"><span class="nav-number">1.10.</span> <span class="nav-text">14.如何实现容器的跨主机网络通信</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wu Tian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/haruto.model.json"}});</script></body>
</html>
