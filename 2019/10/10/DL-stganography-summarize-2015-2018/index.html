<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Steganography," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="Deep Learning in steganography and steganalysis from 2015 to 2018摘要近10年来，对隐藏在图像中的信息的检测主要是通过富模型(RM)的计算来实现的，接着是集成分类器(EC)的分类。2015年，首个使用卷积神经网络(CNN)的研究，通过深度学习逼近两步方法(EC+RM)的结果，获得了隐写分析的第一个结果。因此，在2015-2018年期间">
<meta name="keywords" content="Steganography">
<meta property="og:type" content="article">
<meta property="og:title" content="DL stganography summarize(2015-2018)">
<meta property="og:url" content="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/index.html">
<meta property="og:site_name" content="fennudehaogua.top">
<meta property="og:description" content="Deep Learning in steganography and steganalysis from 2015 to 2018摘要近10年来，对隐藏在图像中的信息的检测主要是通过富模型(RM)的计算来实现的，接着是集成分类器(EC)的分类。2015年，首个使用卷积神经网络(CNN)的研究，通过深度学习逼近两步方法(EC+RM)的结果，获得了隐写分析的第一个结果。因此，在2015-2018年期间">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/ba9ed68e9a1a6d9ee6646092cb1121aa.png">
<meta property="og:image" content="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/5cbcba7c8e422f2f6f624ab5dc6a5e2e.png">
<meta property="og:image" content="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/a4344f7b944a8eeafeaa5825110ef7bd.png">
<meta property="og:image" content="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/d624460a087bc0268c703d23101864d6.png">
<meta property="og:image" content="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/4fba0196fac4a226e05e8da6da4e8113.png">
<meta property="og:image" content="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/731a2ca9695e51acda8e90fcc0e94043.png">
<meta property="og:image" content="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/5a9f7aaed6506de79ec4559c124c0b8c.png">
<meta property="og:image" content="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/f9806a05a1ac625bae349f5147f4b641.png">
<meta property="og:image" content="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/cfe793106effb88aba99633734fa645c.png">
<meta property="og:image" content="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/7fbfe92e205781af7e0f63676a13d492.png">
<meta property="og:updated_time" content="2019-10-10T12:10:41.397Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DL stganography summarize(2015-2018)">
<meta name="twitter:description" content="Deep Learning in steganography and steganalysis from 2015 to 2018摘要近10年来，对隐藏在图像中的信息的检测主要是通过富模型(RM)的计算来实现的，接着是集成分类器(EC)的分类。2015年，首个使用卷积神经网络(CNN)的研究，通过深度学习逼近两步方法(EC+RM)的结果，获得了隐写分析的第一个结果。因此，在2015-2018年期间">
<meta name="twitter:image" content="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/ba9ed68e9a1a6d9ee6646092cb1121aa.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/"/>





  <title>DL stganography summarize(2015-2018) | fennudehaogua.top</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?727b9992a1a14607aebb47500e5bcc08";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










    <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>
    <a href="https://github.com/fennudehaogua"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png" alt="Fork me on GitHub"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fennudehaogua.top</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">好记性不如烂笔头</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fennudehaogua.top/2019/10/10/DL-stganography-summarize-2015-2018/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wu Tian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jiansheng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fennudehaogua.top">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">DL stganography summarize(2015-2018)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-10T20:07:49+08:00">
                2019-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Steganography/" itemprop="url" rel="index">
                    <span itemprop="name">Steganography</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Deep-Learning-in-steganography-and-steganalysis-from-2015-to-2018"><a href="#Deep-Learning-in-steganography-and-steganalysis-from-2015-to-2018" class="headerlink" title="Deep Learning in steganography and steganalysis from 2015 to 2018"></a>Deep Learning in steganography and steganalysis from 2015 to 2018</h1><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>近10年来，对隐藏在图像中的信息的检测主要是通过富模型(RM)的计算来实现的，接着是集成分类器(EC)的分类。2015年，首个使用卷积神经网络(CNN)的研究，通过深度学习逼近两步方法(EC+RM)的结果，获得了隐写分析的第一个结果。因此，在2015-2018年期间，大量的出版物表明，在空域隐写分析、JPEG隐写分析、选择信道感知隐写分析和定量隐写分析方面，可以获得更好的性能。本章从现有的角度讨论隐写分析中的深度学习，通过展示不同的神经网络，这些神经网络是在2015-2018年期间，通过特定于隐写分析学科的方法进行评估的。本章不打算重复机器学习或深度学习的基本概念。因此，我们将以一种通用的方式给出一个深度神经网络的结构，我们将展示文献中针对不同的隐写分析场景提出的网络，最后，我们将讨论基于GAN的隐写术。</p>
<p>索引词：隐写术，隐写分析，深度学习，GAN</p>
<h1 id="隐写术与隐写分析中的深度学习"><a href="#隐写术与隐写分析中的深度学习" class="headerlink" title="隐写术与隐写分析中的深度学习"></a>隐写术与隐写分析中的深度学习</h1><p>自20世纪50年代以来，人们就开始研究神经网络。最初，他们打算去模拟大脑的行为。在计算机科学，尤其是人工智能领域，它们已经被用于学习目的达30年之久。大约十年前，神经网络被认为学习时间太长，而且不如支持向量机或随机森林这样的分类器有效。</p>
<p>随着最近在神经元网络[7]领域的进展，由于图形显卡(gpu)提供的计算能力，以及最后感谢丰富的数据，深度学习方法被提出作为神经网络的自然扩展。自2012年以来，这些深度网络深刻地标记了信号处理和人工智能领域，因为它们的性能使其有可能超越最先进水平，而且也解决了科学家未能解决的[55]问题。</p>
<p>在隐写分析中，8年来，图像中隐藏信息的检测主要是通过计算一个富模型(RM)[25]，然后由一个继承分类器(EC)[48]进行分类。2015年，第一项使用卷积神经网络(CNN)的研究首次获得了接近两步方法(EC+RM)结果的深度学习隐写分析结果[74]。因此，在2015 -2018年期间，许多出版物已经表明，可以在空间隐写分析、JPEG隐写分析、边信息隐写分析、定量隐写分析等方面获得更好的性能。</p>
<p>在1.1节中，我们一般地介绍了深度神经网络的结构。本节的重点是隐写分析中现有的内容，并应通过阅读人工学习，特别是梯度下降法和随机梯度下降法来补充。在第1.2节中，我们将讨论卷积模块的不同步骤。在第1.3节中，我们将处理复杂性和学习时间。在第1.4节中，我们将给出深度学习和过去方法之间的联系。在第1.5节中，我们将回到在2015-2018年期间针对不同的隐写分析场景提出的不同网络。最后，在1.6节中，我们将讨论GAN的隐写术，该隐写术采用先序算法ASO[52]在两个网络之间建立一个博弈。</p>
<h2 id="一个深度神经网络的构建模块"><a href="#一个深度神经网络的构建模块" class="headerlink" title="一个深度神经网络的构建模块"></a>一个深度神经网络的构建模块</h2><p>在接下来的小节中，我们回顾一下卷积神经网络(CNN)的主要概念。更重要的是,我们将基于Yedroudj-Net2网络发表在2018年[101]回顾的基本构建网络模块,并且它继承了Alex-Net[53]的思想,以及其思想还继承了为解决隐写分析问题研发的第一个网络QianNet,[74],Xu-Net[95],和Ye-Net[99]。</p>
<h3 id="卷积神经网络的整体视图"><a href="#卷积神经网络的整体视图" class="headerlink" title="卷积神经网络的整体视图"></a>卷积神经网络的整体视图</h3><p>在描述神经网络的结构及其基本块之前，有必要记住，神经网络属于机器学习类。在监督学习的情况下，这是我们最关心的情况，必须要有一个图像数据库，每个图像，要有它的标签，也就是说，它的类。</p>
<p>深度学习网络是能够直接获取原始输入数据的大型神经网络。在图像处理中，网络是由构成图像的像素直接驱动的。因此，深度学习网络以一种联合的方式学习图像的紧凑的内在特征(我们说的特征映射或潜在空间)，同时学习允许分类的分离边界(我们也说的分离计划)。</p>
<p>学习协议类似于经典的机器学习方法。每个图像都作为网络的输入。每个像素值被传递给一个或多个神经元。网络由给定数量的块组成。一个块由神经元组成，它们接受真实的输入值，执行计算，然后将实际计算的值传递给下一个块。因此，神经网络可以用一个有向图来表示，其中每个节点代表一个计算单元。然后，通过向网络提供由图像及其标签组成的示例来完成学习，由于反向传播机制，网络修改了这些计算单元(它学习)的参数。</p>
<p>用于隐写分析的卷积神经网络主要由三个部分组成，我们称之为模块:<strong>预处理模块、卷积模块和分类模块</strong>。作为例证，图1.1概述了Yedroudj等人在2018年提出的网络[101]。该网络处理256×256的灰度图像。</p>
<p><img src="/2019/10/10/DL-stganography-summarize-2015-2018/ba9ed68e9a1a6d9ee6646092cb1121aa.png" alt=""></p>
<h3 id="预处理模块"><a href="#预处理模块" class="headerlink" title="预处理模块"></a>预处理模块</h3><p><img src="/2019/10/10/DL-stganography-summarize-2015-2018/5cbcba7c8e422f2f6f624ab5dc6a5e2e.png" alt=""></p>
<p>从图1.1中可以看出，在预处理模块中，图像被30个高通滤波器滤波。2015-2018年期间，用于隐写分析的大多数网络都使用一个或多个高通滤波器作为预处理。一个高通滤波器的核的例子-S5a滤波器[25]-在公式1.1中给出。这一初步的滤波步骤使得网络收敛速度更快，当学习基数太小(只有4000对大小为256×256的cover/stego图像)时，可能会获得良好的性能[100]。然后将滤波后的图像传输到网络的第一个卷积块。注意，最近的SRNet[9]网络没有使用任何固定的预过滤器，而是学习过滤器。因此，它需要一个更重要的数据库(超过15000对大小为256×256的cover/stego图像)和强大的初始化技术。请注意，在社区中有一个争论，是应该使用固定的过滤器，还是使用预先选择的值初始化过滤器，然后继续学习，还是使用随机初始化学习过滤器。在2019年初，在实践中(实际情况为[44])，最佳选择可能与学习数据库的大小(不一定是BOSS[4]或BOWS2[5])以及使用或不使用迁移学习的可能性有关。</p>
<h3 id="卷积模块"><a href="#卷积模块" class="headerlink" title="卷积模块"></a>卷积模块</h3><p>在卷积模块中，我们找到了几个宏观计算单元，我们称之为块。块由计算单元组成，这些计算单元接受实际输入值、执行计算并返回实际值，这些值将提供给下一个块。具体地说，一个块接受一组特征映射(=一组图像)作为输入，并返回一组特征映射作为输出(=一组图像)。在一个块中有许多操作，包括以下四种操作:<strong>卷积(参见1.2.1节)、激活(参见1.2.2节)、池化(参见1.2.3节)和最后的归一化(参见1.2.4节)</strong>。</p>
<p>请注意，在卷积网络出现之前，文献中定义的神经元概念仍然存在，但它<strong>不再作为数据结构</strong>存在于神经网络库中。在卷积模块中，我们必须把一个神经元想象成<strong>一个计算单元</strong>，在卷积运算中，对于卷积核在特征映射中所占的位置，进行核与所考虑的像素组之间的加权和。神经元的概念对应于输入数据(像素)与特定于神经元的数据(卷积核的权重)之间的标量积，然后在R中应用一个R，R称为激活函数。然后，通过扩展，我们可以认为池化和归一化是神经元特有的操作。</p>
<p>因此，块的概念在概念上相当于神经元的“层”。请注意，在深度学习库中，我们将层称为任何基本操作，如卷积、激活、池化、归一化等。为了消除歧义，对于卷积模块我们将讨论块和操作，我们将避免使用术语层。</p>
<p>不包括预处理块,Yedroudj-Net网络[101]卷积模块由5个卷积块组成，像QianNet[74]和XuNet[95]。Ye-Net[99]网络卷积模块由8个卷积块,SRNet网络[9]卷积模块有11个。</p>
<h3 id="分类模块"><a href="#分类模块" class="headerlink" title="分类模块"></a>分类模块</h3><p>卷积模块的最后一块(见前一节)连接到分类模块，分类模块通常是一个由一到三个块组成的全连接的神经网络。这个分类模块通常是一个传统的神经网络，其中每个神经元全连接到前一个神经元块和下一个神经元块。</p>
<p>全连接的块通常以softmax函数结束，该函数对[0,1]之间的网络输出进行规范化，使输出的和等于1。输出被不精确地命名为“概率”。我们将保留这个命名。因此，在通常的二进制隐写分析场景中，网络提供两个值作为输出:一个给出分类为第一类的概率(例如，cover类)，另一个给出分类为第二类的概率(例如，stego类)。然后通过返回具有最高概率的类来获得分类决策。</p>
<p>注意，在这个分类模块的前面，我们可以找到一个特定的池化操作，如全局平均池、空域金字塔池化(SPP)[32]、统计矩提取器[91]等。这样的池化操作返回一个固定大小的值向量，即固定维的特征映射。池化操作旁边的块总是连接到一个固定大小的向量。因此，此块具有固定数量的输入参数。因此，在不修改网络拓扑的情况下，可以将任何大小的网络映像显示出来。例如，该属性可以在Yedroudj-Net[101]网络、Zhu-Net[107]网络或Tsang等网络[91]中得到。</p>
<p>还请注意，【91】是截止本章写作日期2018年底的唯一一篇认真考虑了输入图像维数不变网络的可行性的论文。这个问题仍然悬而未决。[91]中提出的解决方案是平均池化概念的一个变体。目前没有足够的研究主题确定正确的网络拓扑结构是什么,如何学习网络、嵌入的比特数量的多少会影响学习,我们是否应该考虑平方根法的学习在一个固定的安全级别或任何载荷大小,等等。</p>
<h2 id="卷积模块的不同步骤"><a href="#卷积模块的不同步骤" class="headerlink" title="卷积模块的不同步骤"></a>卷积模块的不同步骤</h2><p>在第1.1.3节中，我们指出，卷积模块中是一个块包含了以下四种操作中的一个变量:卷积(见第1.2.1节)、激活(见第1.2.2节)、池化(见第1.2.3节)和归一化(见第1.2.4节)。现在让我们更详细地解释一个块中的每个步骤(卷积、激活、池化和归一化)。</p>
<h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>块内的第一个处理通常是在输入特征映射上应用卷积。</p>
<p>注意，对于预处理块(参见图1.1)，只有一个输入图像。因此，在输入图像和滤波器之间进行卷积。在Yedroudj-Net网络中，有30个从SRM滤波器[25]中提取的高通滤波器。在旧的网络中，只有一个预处理过滤器[74,72,95]。 </p>
<p>除了预处理块之外，在其他块中，一旦应用了卷积，我们将应用激活步骤(参见1.2.2节)、池(参见1.2.3节)和归一化(参见1.2.4节)。然后，我们获得了一个新的图像，命名为特征映射。</p>
<p>形式上，设I(0)为预处理块的输入图像。令F(k)(l) 代表l（l={1，…，L}）块中的第k(k∈{1，…，K(l)})个滤波器，用L表示块的数目，用K(L)表示第L个块的过滤器数目。</p>
<p>滤波图像在预处理块内的卷积与第k个滤波器结果,表示为I(k)(1),例如:</p>
<p><img src="/2019/10/10/DL-stganography-summarize-2015-2018/a4344f7b944a8eeafeaa5825110ef7bd.png" alt=""></p>
<p>从第一块卷积模块的最后一块卷积(见图1.1),卷积不太常规,因为k(l−1)特征映射(k(l−1)图像)作为输入,表示I(l−1) (k)其中k = {1,…K (l−1)}。</p>
<p>由编号为l的卷积块得到的第k个滤波后的图像的“卷积”实际上是k (l−1)个卷积的和，例如:</p>
<p><img src="/2019/10/10/DL-stganography-summarize-2015-2018/d624460a087bc0268c703d23101864d6.png" alt=""></p>
<p><img src="/2019/10/10/DL-stganography-summarize-2015-2018/4fba0196fac4a226e05e8da6da4e8113.png" alt=""></p>
<p>表示给定k值的一组k (l−1)个滤波器。</p>
<p>这种操作是很不寻常的，因为每个特征映射都是由K(l−1)个卷积和得到的，每个卷积使用不同的滤波核。这个操作可以看作是空域卷积加上channels-axis上的和。</p>
<p>这个加入操作可以由一个独立的操作称为可分离卷积或切除可分离旋转[16],它允许结合一个非线性操作(一个激活函数)如ReLU，在空间卷积和“深度”轴卷积(我们使用的“深度”轴1×1过滤器)之间。因此，深度可分离的卷积可以粗略地恢复为卷积的加权和，这是一个比仅仅是卷积和更具描述性的操作(见公式1.3)。</p>
<p>如果我们将等式1.3中描述的操作替换为一个深度可分的卷积操作，该操作集成在一个Inception模块中(<strong>Inception主要允许使用可变大小的过滤器</strong>)，我们可以得到一个性能改进的[16]。在隐写分析中，这点在文章[107]中已经观察到，当修改图1.1中卷积模块的前两层时。</p>
<p>提醒一下,在本文档中,我们将命名一个卷积块的集合操作为:<strong>一个卷积</strong>(或多个运算并行执行的Inception,和两个旋转切除分离卷积的情况下),<strong>几个激活函数</strong>,一个<strong>池化</strong>和一个<strong>归一化</strong>。这些步骤可以正式表达了一个简化的方法(案例没有Inception或切除分离卷积)用递归形式的连接特性映射的输入块的特征映射的输出块:</p>
<p><img src="/2019/10/10/DL-stganography-summarize-2015-2018/731a2ca9695e51acda8e90fcc0e94043.png" alt=""></p>
<p>其中b(l)(k)∈R的标量代表卷积偏置,f()激活函数应用过滤图像的逐个像素,pool(),池化函数应用于相邻部分,最后归一化函数。</p>
<p>注意，过滤器的内核(也称为权值)和偏差必须学习，因此在反向传播阶段进行修改。</p>
<h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>一旦每个卷积的卷积块被应用,激活函数,f()(见Eq。1.4),是应用在滤波图像中每个值,˜I(l) (k)(Eq。1.2和1.3)。这个函数被称为激活函数，它参考了神经元网络第一次研究中发现的二元激活的概念。激活函数可以例如是一个绝对值函数f(x) = | x |,正弦函数f (x) =sinus(x)一个高斯函数在[74]f (x) = e−x2/σ2,一个ReLU(修正线性单位):f (x) = max (0, x)等。</p>
<p>这些函数打破了卷积过程中线性滤波产生的线性。非线性是一个强制性的特性，在两步机器学习方法中也被利用，例如在弱分类器阈值合集分类器[48]中，或者通过最终的多数投票，或者在具有最小最大特征[25]的富模型中。所选的激活函数必须是可微的，以执行反向传播。在选择激活函数时，最常用的保留解是那些其导数不需要太多计算就可以求出的解。此外，还避免了具有低斜率区域的函数，如双曲正切函数，因为这类函数在反向传播过程中会使反向传播的梯度值被消去(即梯度消失的现象)，从而使学习变得不可能。因此，在许多网络中，经常可以找到ReLU激活函数或其变体。例如，在Yedroudj-Net网络中(参见图1.1)，我们找到了绝对值函数、参数化的HardTanh函数(Trunc函数)和ReLU函数。在SRNet网络[9]中，我们只找到ReLU函数。</p>
<h3 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h3><p>池化操作是计算一个本地邻居的平均值或最大值。在图像对象分类领域中，最大池保证了在重新计算特征时的局部不变性。也就是说，在大多数隐写分析网络中，最好使用平均池来保护极低功耗的隐写噪声。</p>
<p>此外，池通常与下采样操作联合使用(当stride大于1时)以减小大小(如高度，宽度)即得到的特征映射与前一个特征映射相比。例如，在Yedroudj-Net(参见图1.1)中，块2、块3和块4将输入特征映射的大小减少四倍。我们可以通过大于1的stride的池化操作，看作是带有初步低通滤波的常规子抽样。这对于减少GPU的内存占用非常有用。这个步骤也可以理解为去噪，从信号处理的角度来看，它会导致信息的丢失。最好不要在前几个块中添加子样本，因为它最初是在[72]中突出显示的，在Xu-Net[95]、Ye-Net[99]、Yedroudj-Net[101]中设置的，并在SRNet[9]中重新评估。</p>
<h3 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h3><p>在隐写分析提出的第一个网络,在此2014−2016年初期间(Tan and Li [88], Qian et al.[74], Pibre and al. [72),如果有一个归一化,它仍然是空间邻域的局部,与局部对比归一化,或内在特征,与局部响应归一化。</p>
<p>批量归一化出现了一个大的改善。批量归一化(batch normalization,BN)在2015年[43]提出，并被广泛采用。这种归一化存在于大多数用于隐写分析的新网络中。BN<a href="参见公式1.5">43</a>包括对特征图中每个特征的分布进行归一化处理，使平均值为零，方差统一，如果需要，还可能允许分布的重新缩放和重新平移。</p>
<p>给定一个随机变量X的实现是一个值X∈R的特征映射,这个值X的BN:</p>
<p><img src="/2019/10/10/DL-stganography-summarize-2015-2018/5a9f7aaed6506de79ec4559c124c0b8c.png" alt=""></p>
<p>其中E (X)的期望,Var [X]方差,γ和β两个代表re-scaling和re-translation标量。期望E(X)和方差Var[X]每批更新,而γ和β被反向传播学习。在实践中，BN使得学习对参数[43]的初始化不敏感，允许使用较高的学习率，加快了学习速度，提高了分类[15]的准确性。</p>
<p>在Yedroudj-Net中,γ和β被当作一个独立的层称为规模层(见图1.1),以同样的方式存于ResNet[33]中。性能的提高非常小。</p>
<h3 id="内存-时间复杂度和效率"><a href="#内存-时间复杂度和效率" class="headerlink" title="内存/时间复杂度和效率"></a>内存/时间复杂度和效率</h3><p>由于使用了经过深思熟虑的随机梯度下降法，网络学习可以被认为是具有许多未知参数的函数的优化。与传统的神经网络一样，用于隐写分析的CNN网络有大量的参数需要学习。例如，在不考虑批量归一化和规模参数的情况下，文献[101]中所描述的Xu-Net[95]网络的参数数量为5万个左右。相比之下，网络Yedroudj-Net[101]，有许多50万左右的未知参数。</p>
<p>在实践中,使用代GPU (Nvidia TitanX)英特尔酷睿i7-5930k的3.50GHz×12 32GB的内存, Yedroudj-Net网络需要不到一天学习4000对256×256 cover/stego “BOSS[4]”中的图像,三天14000对256×256的cover/stego的图像“BOSS+BOWS2[5]”,超过七天的112000对256×256 cover/stego的图像“BOSS+ BOWS2+一个虚拟的数据库增加[100]”。这些长时间的学习是由于数据库很大，需要反复浏览，使得反向传播过程使网络收敛。</p>
<p>由于需要学习的参数数量很大，神经网络需要一个包含大量示例的数据库，该数据库位于幂律区域[34]，允许不同网络之间进行比较。此外，学习数据库中的例子必须足够多样化，以获得良好的泛化网络。对于CNN隐写分析,与当前网络(2018年),样例的数量需要达到的良好的性能(即一样好使用丰富的模型[25]和一个分类器[48]),在没有源失配的情况下，最有可能在按次序的10000张图片(5000cover和5000stego),大小为256×256[100]。但是，示例的数量仍然不够[100]，因为仅通过增加示例的数量就可以提高性能。所谓的不可约误差区域[34]可能需要100多万张图像[105];因此，它应该至少多100倍的图像。此外，使用的图像具有非常小的尺寸，这将有必要能够对较大的图像也有效。因此，很明显，今后必须找到一个或多个解决办法，以达到不可减少的误差范围。这可以通过庞大的基础，几周或几个月的学徒期，或通过更好的网络，或通过有待发明的解决方案来实现。</p>
<p>请注意，当然，有一些技巧可以提高性能，并且可能更快地到达不可避免误差部分。我们可以使用迁移学习[73]或课程学习[99]开始学习一个已经学习过的网络。我们可以使用一组CNNs[97]，或者使用由子网络[58]组成的网络，这样可以节省几个百分点的准确率。实际上可以增加数据库[53]，但这并不能解决增加学习时间的问题。我们可以添加与测试数据库类似的数据库的图像，例如在BOSS和BOWS2用于学习的情况下，在BOSS[99]、[100]上进行测试。在实践中，我们是否能够访问与所测试的数据库类似的数据库，这一点并不明显。我们可以确定设备，并对测试数据库的图像进行类似的开发[100]，以增加学习基础。同样，这种方法很难实现，而且成本很高。注意,一般共享的人玩Kaggle比赛是赢的主要实用规则[54]:(i)使用现代网络的整体(ResNet，DenseNet,等等),学会了例如ImageNet,然后使用迁移学习, (ii)数据增长,(iii)最终收集数据来增加数据库的大小。</p>
<h3 id="深度学习和过去方法的联系"><a href="#深度学习和过去方法的联系" class="headerlink" title="深度学习和过去方法的联系"></a>深度学习和过去方法的联系</h3><p>在前面的章节中，我们解释了深度学习的学习是通过类似于梯度下降的技术，将含有许多未知参数的函数最小化。在本小节中，我们将与隐写术/隐写分析社区中关于该主题的先前研究建立联系。本小节试图与该领域过去的一些研究建立联系，并试图揭开深度学习的神秘面纱。</p>
<p>卷积是CNN网络的重要组成部分。学习过滤器内核(权值)是通过使用反向传播过程最小化分类错误来完成的。因此，这是一个简单的优化过滤器内核。这种策略最早可以在2012年的文章[35]中使用富模型和集成分类器的两步方法中找到。通过单纯形算法优化得到用于计算特征向量的核值。在本文中，我们的目标是最小化集成分类器给出的分类错误的概率，其方法与CNN相同。CNNs具有相同的目标，即构建非常适合隐写分析的自定义内核。</p>
<p>在预处理块(Ye-Net[99]，Yedroudj-Net[101]，ReST-Net[58]等)刚刚完成的卷积的第一个块，卷积充当一个多频带滤波对预处理块获得的残差执行(见图1.1)。对于第一个块，网络分析不同频段的信号残差。在过去，当计算富模型[25]时，由于使用了过滤器库，一些方法已经应用了类似的思想。一些方法通过使用Gabor滤波器(GFR Rich Models)[86]、[93]，一些使用离散余弦滤波器(DCTR Rich Models)[37]，一些使用可操纵高斯滤波器[2]，一些使用随机投影(PSRM Rich Models)[36]等进行空间频率分解。对于所有这些丰富的模型，这些滤波的结果被用来计算直方图(共现矩阵)，然后作为特征向量。因此，用于隐写分析的CNNs的第一个卷积块与一些丰富模型的空间频率分解有相似之处。</p>
<p>从开始向下采样特征图的卷积块，可以得到几个不同卷积的结果的总和。这相当于通过观察几个波段的线索来积累信号(stego噪声)的存在迹象。我们在过去没有发现这样的原则。积累信号的唯一方法是基于直方图的计算[25,36]，但这种方法不同于CNNs。值得注意的是，在文章[81]中，作者探讨了如何将直方图计算机制融入到CNN网络中，但结果并不令人满意。因此，从第二个块开始，所涉及的创建分隔两个类的潜在空间的机制，即获得每个图像的特征向量，这使得区分cover和stego成为可能，这与在富模型中使用的机制不同。同样，过去的一些技术，如非均匀量化[68]、特征选择[13]、降维[70]等，在CNN网络中也不是直接可见的。</p>
<p>在大多数卷积块中，特征映射的归一化是一块砖。归一化常用于隐写分析，如[52]、[17]、[10]等。在CNN中，除了其他操作外，还要进行归一化，以获得每个特征图的可比较输出值。激活函数在信号中引入了非线性，从而使许多卷积块成为可能。这种非线性现象在以往的集成分类器中通过多数票[48]发现，在富模型中通过最小或最大操作[25]发现。</p>
<p>CNN网络的结构和改善网络性能的砖块在实践中得到了更好的理解。正如我们上面所看到的，在CNN中，有一些部分与过去隐写分析中提出的命题相似。一些砖的CNN也解释为他们指导下计算约束(使用简单的可微的激活函数像ReLU),或促进收敛(非线性允许收敛,激活函数不应该太平坦或陡峭,为了避免消失的梯度或快速变化,避免有捷径允许方向传播中梯度消失,从而允许创建更深层次的网络,批处理归一化,初始化如Xavier，优化如Adam等)。注意，CNNs的一些成分也来自于可微函数的优化理论。</p>
<p>虽然在网络的实践中很容易使用，并且对网络的行为有一定的直观认识，但在理论上仍然缺乏论证。例如，根据一个问题，层的数量，特别是参数的数量应该是多少?在未来几年，毫无疑问，基于AutoML和渐进神经结构搜索(PNAS)的工作精神，用于隐写分析的CNN网络的构建可以自动调整其拓扑结构[62]和[71]。也就是说，该理论还必须试图解释网络内部发生的事情。值得注意的是Stephane Mallat[65]试图从信号处理的角度来解释CNN的工作。机器学习理论家也将更好地解释网络中发生的事情，以及为什么这种数学结构如此有效。 </p>
<p>综上所述，关于两步学习方法与深度学习方法之间的联系，CNN网络以及两步(富模型+集成分类器)方法都无法处理cover源不匹配的问题[12,26]。这是在对象识别[3]等领域中，神经网络方法的批评者所使用的一个缺陷。CNNs学习一个分布，但是如果它在测试阶段不同，那么网络就不能检测它。也许最终的路径是让网络“理解”测试数据库不是作为学习数据库分布的?</p>
<h2 id="2015-2018年期间使用的不同网络"><a href="#2015-2018年期间使用的不同网络" class="headerlink" title="2015 - 2018年期间使用的不同网络"></a>2015 - 2018年期间使用的不同网络</h2><p><img src="/2019/10/10/DL-stganography-summarize-2015-2018/f9806a05a1ac625bae349f5147f4b641.png" alt=""></p>
<p>图1.2给出了2015年至2018年用于隐写术和隐写分析的主要CNNs的年表。使用深度学习方法进行隐写分析的第一次尝试可以追溯到2014年底[88]，当时使用的是自动编码器。2015年初，Qian等[74]提出使用卷积神经网络。一年后，Pibre等[72]提出继续研究。</p>
<p>2016年，第一批与最先进的结果接近的结果是通过CNNs的集成获得的[97]。Xunet[95]CNN被用作CNNs合集的基础学习器。</p>
<p>其他网络在2017年提出，这次是JPEG隐写分析。在[106][105]中，作者受到富模型的启发，提出了预处理，并使用了大型学习数据库。结果接近最先进的技术。在[15]中，受JPEG压缩过程的启发，使用分相构建网络。为了获得比最先进的结果稍好一些的结果，需要一个CNNs集合。在XuNet-Jpeg[96]中，CNN受ResNet[33]的启发，使用了快捷连接技巧，并使用了20层，这也提高了结果的准确性。注意，在2018年，ResDet[42]提出了Xu-Net-Jpeg的变体[96]，结果接近。</p>
<p>这些结果非常令人鼓舞,但对于在其他图像处理任务获得使用深度学习方法[55],隐写分析结果没有“10%更好”相比经典的方法使用一个集成分类器与富模型[48][25],[94]或选择信道感知富模型[20],[21],[18]。2017年，改进CNN结果的主要趋势是使用CNNs集成，通过模仿富模型提取过程或使用ResNet来修改拓扑结构。在大多数情况下，与AlexNet[53]、VGG16[85]、GoogleNet[87]、ResNet[33]等网络相比，设计或实验的工作量非常大，但性能的改善非常小，这激发了这些研究。</p>
<p>到2017年底和2018年，这些研究主要集中在空间隐写分析上。Ye-Net[99]、Yedroudj-Net[100,101]、ReST-Net[58]、SRNet[9]分别于2017年11月、2018年1月、2018年5月、2019年5月出版(网络版于2018年9月出版)。所有这些网络都明显地超越了使用集成分类器[48]和富模型[25]的“旧”两步机器学习范式。这些网络中的大多数可以通过不大的数据库进行学习(例如，来自BOSS+BOWS2的大约15000对大小为256×256的8位编码图像的cover/stego)。</p>
<p>2018年最好的网络是Yedroudj-Net[101]、ReST-Net[58]和SRNet[9]。Yedroudj-Net是一个小的网络，可以在一个非常小的数据库上学习，甚至可以是有效的，即使不使用已知的技巧来提高性能，如迁移学习[73]或数据库的虚拟扩展[99]等。在处理GANs时，这个网络是一个很好的候选者。该网络优于Ye-Net[99]，可以改进以面向其他近期网络[107]。ReST-Net[58]是一个由三个使用各种预处理过滤器的子网络组成的巨大网络。SRNet[9]是一个可以适应空间或Jpeg隐写分析的网络。与Yedroudj-Net相比，它需要虚拟增强和迁移学习等技巧，从而需要更大的数据库。这三种网络将在第1.5.1节中介绍。</p>
<p>继续，2015-2017年，发表的论文主要是空域隐写分析，2017 -2018年，发表的论文主要是JPEG隐写分析。2018年，发表的论文再次以空域隐写分析为主。最后，从2017年底开始，第一批使用GANs的出版物出现了。在第1.6节中，我们提出了使用GAN的新命题，并对每个家族进行了分类。</p>
<p>在下面的小节中，我们报告了截至2018年底的各种场景中最成功的网络。在第1.5.1节中，我们描述了无告知场景，在第1.5.2节中，我们讨论了称为边信道已知(Side Channel Informed,SCA)的场景，在第1.5.3节中，我们处理了JPEG隐写分析无告知情场景和边信道已知场景。在1.5.4节中，我们非常简要地讨论了cover源不匹配，尽管目前使用CNN的建议并不存在。</p>
<p>我们将不处理CNN图像大小不变的场景，因为它还不够成熟。该场景在1.1.4节中进行了简要讨论，Yedroudj-Net[101]、Zhu-Net[107]或Tsang等人[91]的论文给出了优先解决方案。</p>
<p>我们不会采用CNN的定量隐写式分析，它包括估计嵌入的有效载荷大小。这个场景在[14]文章中得到了很好的处理，成为一种新的艺术形式。该方法超越了以前最先进的方法[49][103]，该方法依赖于富模型、集成树和有效的特征归一化。</p>
<p>我们也不会讨论使用CNNs的批量隐写术和汇集隐写分析，尽管[104]中使用两阶段机器学习的工作可以扩展到深度学习。</p>
<h3 id="无边信息的空域隐写分析"><a href="#无边信息的空域隐写分析" class="headerlink" title="无边信息的空域隐写分析"></a>无边信息的空域隐写分析</h3><p>2018年初最成功的空间隐写分析方法是YedroudjNet[101]方法。实验在256×256次采样10000张图像的BOSS数据库上进行。为了进行公平的比较，我们通过比较不需要集成的Xunet[95]、无边信息的Yenet网络[99]以及由空域富模型[25]提供的集成分类器[48]来进行实验。请注意，Zhu-Net<a href="在编写本书的这一章时还没有发布">107</a>对Yedroudj-Net提供了三个改进，使其更加高效。报告的改进Zhu-Net[107]的更新内核过滤的预处理模块(同样是Stamm马修的团队提出的取证[6]),取代了[16]中提出的前两个卷积块切除两个模块的可分离旋转,最后将全局平均池化替换为[32]提出的一个空域金字塔池化(SPP)模块。</p>
<p>在2018年5月，提出了ReST-Net[58]方法。它由三个网络组成，构成一个超级网络。每个子网都是一个类似于Xunet的网络[95]，类似于Yedroudj-Net[101]网络，在block<br>2和block4上都有Inception模块。Inception模块包含相同大小的过滤器，每个“路径”(TanH、ReLU、Sigmoid)具有不同的激活函数。第一个子网使用16个Gabor滤波器进行预处理，第二个子网使用16个SRM线性滤波器进行预处理，第三个子网使用14个非线性残差(在SRM上计算的最小和最大值)进行预处理。学习过程需要四个步骤(每个子网一步，超网一步)。在BOSSBasev1.01[4] 512×512上进行S-UNIWARD[39]、HILL[57]、CMD-HILL[59]，结果比Xu-net好2-5%。从结果上看，是集成的概念改进了结果。分开来看，每个子网的性能都比较低。目前，在一个公平的框架内，还没有对Yedroudj-Net和ReST-Net的合集进行比较。</p>
<p>2018年9月，SRNet[9]方法上线。它提出了一个比以前的网络更长的网络，由12个卷积块组成。该网络不进行预处理(学习滤波器)，只对来自第8个卷积块的信号进行子采样。为了避免消失的问题，块2到11使用快捷机制。先启机制也在池化子样例阶段从第8层实现。在[99]或[100]中使用BOWS2数据库对学习基础进行了扩充，并使用课程训练机制[99]将标准有效载荷0.4bpp更改为其他有效载荷。最后，使用Adamax[45]进行梯度下降。该网络可用于空域隐写分析、边信息已知(SCA)空域隐写分析(参见第1.5.2节)和JPEG隐写分析(参见第1.5.3节非SCA或SCA)。总的来说，其原理与以前的网络类似，包括三个部分:预处理(使用学习过滤器)、卷积块和分类块。从简化的角度来看，该网络相当于在Yedroudj-Net网络的第一个卷积块之后添加了5个没有池化的卷积块。为了能够在现代GPU上使用如此大量的块，作者必须将特征映射的数量减少到16个，为了避免渐变消失的问题，他们必须在块内使用[33]中提出的剩余快捷方式的技巧。注意，在前七个块中保留信号大小是一种完全不同的方法。这一观点在[72]中被提出，抑制池化明显改善了结果。使用现代的快捷方式或Inception模块也可以提高性能。</p>
<p>还应该注意的是，训练是端到端的，没有特定的初始化(除非有课程训练机制)。在撰写本章时，这个最初的网络并没有与Yedroudj-Net[101]相比较，也没有与zhu-net[107]相比较，但是可以认为Yedroudj-Net(即zhu-net)的更新与这个网络(SRNet)具有类似的性能。</p>
<h3 id="边信息已知的空域隐写分析"><a href="#边信息已知的空域隐写分析" class="headerlink" title="边信息已知的空域隐写分析"></a>边信息已知的空域隐写分析</h3><p>到2018年底，有两种方法正在集成选择通道的知识，SCA-Ye-Net是SCA版本的Ye-Net[99]，SCA-SRNet是SCA版本的SRNet[9]。其思想是使用一个用于不知道边信息的隐写分析的网络，不仅注入待隐写分析的图像，而且注入修改概率图。因此，我们假设Eve知道或者能够很好的估计修改概率图[80]，即Eve可以访问边信道信息。</p>
<p>给出了预处理块SCA-Ye-Net[99]的修改概率图，相当于SCA-SRnet[9]的第一个卷积块，但是内核值被它们的绝对值所代替。卷积后，将每个特征映射与对应的卷积“修改概率映射”逐点累加。注意，第一个卷积的激活函数(预处理块或第一个块)被ReLU替换(如果还不是这样的话)。在SCA-Ye-Net中，截断激活函数(文中的截断线性单元(TLU))确实被ReLU代替。这使得在与图像相关的整个网络信息和与修改概率图相关的另一个网络信息中“几乎”传播(前向传递)成为可能。</p>
<p>注意，在SCA-CNN中转换非SCA-CNN的过程受到了[21]和[18]中提出的修改概率映射传播的启发。这两篇论文是对之前的maxSRM富模型[20]的改进。在maxSRM中，使用的不是在共现矩阵中累积出现的次数，而是对局部概率的最大值进行累积。在[21]和[18]中，其思想是对修改概率映射进行类似于滤波的变换，然后使用修改概率映射的变换版本来更新共现矩阵，而不是原始的修改概率映射。对这一原理的模仿最初被整合到Ye-net中用于CNN隐写分析，这一概念很容易被大多数现代CNN所取代。</p>
<h3 id="JEPG隐写分析"><a href="#JEPG隐写分析" class="headerlink" title="JEPG隐写分析"></a>JEPG隐写分析</h3><p>2018年底最佳JPEG CNN是SRNet[9]。请注意，这个网络是唯一一个已提出的边信息已知版本。</p>
<p>列出并快速讨论以前用于JPEG隐写分析的cnn是很有趣的。第一个网络发表于2017年2月，是Zeng等人的网络，用100万幅图像进行评估，并对其进行了一点点的stego失配评估[106][105]。然后在IH&amp;MMSec的2017年6月，提出了两种网络:PNet[15]和XuNet-Jpeg[96]。最后，SRNet[9]于2018年9月上线。</p>
<p>在Zeng等人的网络[106][105]中，预处理块将去量化的(真实值)图像作为输入，然后与25个DCT基进行卷积，对这25个图像进行量化并截断。这个预处理块使用手工制作的过滤器内核(DCT基础)，内核的值是固定的，这些过滤器的灵感来自于DCTR富模型[37]。有三种不同的量化，因此预处理块给出了3×25的残差图像。CNN由3个子网络组成，每个子网络产生一个512维的特征向量。子网的设计灵感来自Xunet[95]。这三个特征向量由三个子网络输出，然后给出一个完全连接的结构，最后的网络以一个softmax层结束。</p>
<p>与空域隐写分析类似，这个网络使用了一个预处理块，灵感来自于一个富模型[37]。注意，当今最有效的富模型是Gabor过滤器富模型[93]。另外，请注意这个网络利用了来自不同子网络的特性集合的概念。Zeng等人的网络不如Xu-Net-Jpeg[96]有效，但在富模型的引导下，给出了一个有趣的第一种方法。</p>
<p>PNet的主要思想(和VNet效率那么高,但是需要更少的内存)[15]是模仿相位感知富模型,如DCTR[37],PHARM [38], GFR[93],因此有一个输入图像分解为64特征映射代表64阶段的Jpeg图像。预处理块以去量化(真实值)图像为输入，与四个滤波器进行卷积，“SQUARE5×5”来自空域富模型[25]，“点”高通滤波器(参考“catalyst kernel”)补充“SQUARE5×5”，以及两个方向Gabor滤波器(角度为0和pi)。</p>
<p>就在第二个卷积块之后，一个“相位分离模块”将剩余图像分割成64个特征映射(一个图=一个相位)，这与在富模型中所做的工作类似。一些有趣的把戏已经使用,如(1)犹如预处理的固定块,和第二个卷积可学的值,(2)一个聪明的BN的更新参数,(3)使用“滤波器组选项”,实际上构建子网,(4)包装5折交叉验证,(5)为了得到网络的平均误差，对最后5次求值(6)在每个epoch开始时对数据库进行洗牌，以获得更好的BN行为，并有助于推广，（7）最终使用集成。有了这些诀窍，PNet在no-SCA和SCA版本(集成分类器+GFR)中击败了经典的两步机器学习方法。</p>
<p>Xu-Net-Jpeg[96]甚至更有吸引力，因为这种方法甚至比PNet稍好一些，而且不像PNet那样需要很强的领域灵感。Xunet-jpeg的灵感来自于ResNet[33]，这是一个来自机器学习社区的非常稳定的网络。由于使用了快捷方式，ResNet允许使用更深层次的网络。Xu-Net,预处理块需要作为输入使失去(实际值)图像,然后用16卷积图像DCT基础(在同一个精神Zeng<br>et al.网络[106][105]),然后应用一个绝对值,截断,和一组卷积,BN,ReLU直到获得384维的特征映射,给一个完全连接块。我们可以注意到，最大池化或平均池化被卷积所取代。因此，这个网络非常简单，在2017年是最先进的。在某种程度上，这一结果表明，由机器学习提出的网络具有很强的竞争力，并且没有那么多的领域知识需要整合到网络的拓扑结构中，从而获得一个非常高效的网络。</p>
<p>2018年，最先进的JPEG隐写分析(也可以用于空间隐写分析)CNN是SRNet[9]。这个网络在前面的1.5.1节中已经介绍过了。请注意，对于SRNet的边信息已知版本，每个DCTs系数的嵌入更改概率是使用DCT基的绝对值在空间域中第一次映射回来的。这个边通道映射然后进入网络并与每个内核进行卷积(第一个卷积作为预处理块)。这些卷积使得过滤器内核被修改为它们的绝对值。通过卷积后，将特征映射与卷积后的边信道映射的平方相加。注意,，在JPEG富模型中最近提出的侧通道感知隐写分析,边信道映射的建设,特别是</p>
<p><img src="/2019/10/10/DL-stganography-summarize-2015-2018/cfe793106effb88aba99633734fa645c.png" alt=""></p>
<p>定义与SCA-Ye-Net版本(SCA-TLU-CNN)[99]集成的边信道映射十分相似。</p>
<h3 id="关于失配现象场景的讨论"><a href="#关于失配现象场景的讨论" class="headerlink" title="关于失配现象场景的讨论"></a>关于失配现象场景的讨论</h3><p>失配(cover源失配或stego失配)是机器学习中存在的一种现象，由于学习库的分布与测试库的分布不一致，导致分类性能下降。问题不在于机器学习算法的泛化能力，而在于训练和测试库之间缺乏类似的例子。失配问题远远超出了隐写分析的范围。</p>
<p>在隐写分析中，造成这种现象的原因有很多。Cover源的不匹配可能是由于使用不同的照片传感器、不同的数字处理、不同的相机设置(焦距、ISO、镜头等)、不同的图像大小、不同的图像分辨率等造成的。不同的嵌入算法会产生不同的嵌入比特数，从而导致stego不匹配。</p>
<p>即使还没有得到很好的处理和理解，错配(cover源错配(CSM)或stego错配)仍然是未来几年该学科的主要问题。“阿拉斯加挑战”的结果将在2019年美国游泳协会(ACM)IH&amp;MMSec大会上公布，并将继续进行反思。</p>
<p>到2018年，CSM已经有10年的历史了。有两种主要的思潮，还有一种更奇特的思潮:</p>
<p>•第一种思潮是所谓的整体思潮(即全局性的、宏观的或系统的)，它包括学习所有的分布[64]和[63]。使用单一的CNN和数以百万计的图像[105]是这种思潮的逻辑延续。请注意，此场景不考虑在学习期间可以使用测试集。这个场景与在线场景类似，其中最后一个玩家(从博弈论的角度来看)是隐写者，因为在在线场景中，隐写者可以在设置隐写分析器时更改其策略。</p>
<p>•第二种思潮是原子主义的(=分区的、微观的、分析的、分治式的或个体化的)，包括对分布进行分区[67]，也就是说，创建一个分区，并为分区的每个单元关联一个分类器。注意，在[11]中给出了一个原子方法的例子，该方法使用CNN多分类器进行stego失配管理。在[11]中给出的想法已经被阿拉斯加挑战的获胜者使用。请再次注意，此场景不考虑在学习期间可以使用测试集。这个场景中可以吸收一个在线场景当最后一名玩家(从博弈论的角度来看)是隐写者因为在网上场景隐写者可以在隐写分析者设定后改变其策略。</p>
<p>•最后,奇异的思潮认为有一个基本的测试(远远超过一个图像),这基本是可用的,可用在学习(没有标签)。这个场景可以被比作离线场景，在离线场景中，最后一个玩家(从博弈论的角度来看)是隐写分析器，因为在离线场景中，隐写分析器更像是取证场景。在这一潮流中，有类型域适应的方法，或特征的迁移GTCA[61]， IMFA [50]，CFT[22]，其思想是定义一个不变的潜在空间。另一种方法是ATS[56]，它仅使用测试数据库执行无监督分类，并且需要嵌入算法来重新嵌入来自测试数据库的图像中的负载。</p>
<p>这三种潮流可以帮助CNN找到方法来整合本文的观点。也就是说，最终的解决方案可能是检测到失配现象并发出报警或禁止决策[46]。简而言之，整合一种比整体主义或原子主义更聪明的机制。</p>
<h2 id="基于GAN的隐写"><a href="#基于GAN的隐写" class="headerlink" title="基于GAN的隐写"></a>基于GAN的隐写</h2><p>在Simmons的创始文章[84]中，隐写术和隐写分析被定义为三人游戏。通常被称为Alice和Bob的隐写者希望在不被第三方怀疑的情况下交换消息。他们必须使用无害的媒介，如图像，并将信息隐藏在这种媒介中。通常被称为Eve的隐写分析者负责观察Alice和Bob之间的交流。Eve必须检查这些图像是否是自然的，也就是说，cover图像，或者它们是否包含一个信息，即stego图像。</p>
<p>Alice,Bob和Eve之间的博弈概念与博弈论中的一致。每个玩家都试图找到使他的奖金最大化的策略。为此，我们将问题表示为寻求优化的最小-最大问题。如果存在最优解，则称为纳什均衡解。当所有的玩家都使用纳什均衡的策略时，任何玩家策略的改变都会导致其他玩家的反击，从而增加他们的收益。</p>
<p>2012年，Schottle和Bohme[77]、[78]以简化假设建模隐写术和隐写分析问题为例，提出了正式的解决方案。原理图Schottle和Bohme命名这个方法最优自适应隐写术或战略自适应隐写术反对所谓的原始的自适应隐写术对应算法完成的怎么样如：HUGO(2010)[69],WOW(2012)[40],S-UNIWARD/J-UNIWARD SI-UNIWARD(2013)[39],HILL(2014)[57],MiPOD (2016) [79],Synch-Hill(2015)[19],UED(2012)[30],IUERD (2016) [66],IUERDUpDist-Dejoin2(2018)[60],等等。</p>
<p>也就是说，用博弈论对隐写术/隐写分析问题进行数学形式化处理是困难的，而且常常与实际情况相去甚远。另一种确定纳什均衡的方法是“模拟”游戏。从实用的角度来看，Alice独自完成了整个游戏，这意味着她没有与Bob或Eve交互来构建他的嵌入算法。我们的想法是，她使用3种算法(2种简化版本的算法)来命名代理。每个代理将扮演Alice、Bob和Eve的角色，每个代理在Alice家里运行。让我们注意一下在Alice家里运行的这三个算法:Alice-agent、Bob-agent和eve-agent。Alice-agent的作用是将一个消息嵌入到一个图像中，这样产生的stego图像就不会被Eve-agent检测到，这样Bob-agent就可以提取这个消息。</p>
<p>Alice可以启动游戏，也就是说模拟，和代理“对抗”。一旦代理达到纳什均衡，Alice就停止模拟，现在可以保留Alice-agent，这是她的策略自适应嵌入算法，可以发送Bob-agent提取算法(或任何等价信息)到Bob。Alice和Bob之间的秘密通信现在可以通过嵌入的Alice-agent算法和提取的Bob-agent算法来实现。</p>
<p>第一个前驱方法旨在模拟一个战略适应平衡，从而提出战略嵌入算法始于2011年和2012年。这两种方法分别是MOD[23]和ASO[52][51]。无论是MOD还是ASO，游戏都是由相互竞争的Alice-agent和Eve-agent组成。在这个游戏中，没有使用Bob-agent，因为Alice-agent只是生成一个成本图，然后利用STC[24]来编码和嵌入消息。Alice可以使用Alice-agent生成源图像的成本图，然后她可以轻松地使用STC[24]算法嵌入她的消息并获得stego图像。在Bob这边，他只需使用STC[24]算法从stego图像中检索消息。</p>
<p>在MOD或ASO中，“模拟”是这样的，即迭代以下两个操作，直到达到停止条件:</p>
<p>i)Alice-agent通过询问Oracle(eve-agent)如何更新每个嵌入成本的最佳方式来更新其嵌入成本映射，以使其更难以检测。</p>
<p><strong>在MOD(2011)[23]中</strong>，Eve-agent是一个SVM。Alice-agent通过减少支持向量机分离cover和stego边界来更新嵌入代价。</p>
<p><strong>在ASO(2012)[52]中，</strong>Eve-agent是一个集成分类器[48]，被称为Oracle。Alice-agent通过在cover上隐写来更新其嵌入成本。</p>
<p>在这两种情况下，其思想都是在潜在空间(特征空间)中找到一个位移，其方向是找到cover类和stego类分隔开的超平面。注意，在Ian Goodfellow在2014年[29]中引入的当今术语中，Alice-agent执行对抗式攻击，而Oracle(eve-agent)被命名为鉴别器，即被愚弄的分类器。</p>
<p>ii) Oracle(eve-agent)更新其分类器。用机器学习的术语重新表述，这等同于通过重新学习来进行鉴别更新，以便对Alice-agent生成的stego图像再次进行隐写分析。2014年，Goodfellow等人的[29]使用神经网络“模拟”了一个带有图像生成网络和判别网络的游戏，其作用是判断图像是真实的还是合成的。作者将其命名为生成式对抗网络(GAN方法)。本文中使用的术语随后被广泛采用。此外，神经元网络的使用使得极小极大问题的表达变得容易。然后通过反向传播优化过程进行优化。此外，由于有了深度学习库，现在很容易构建GAN类型的系统。如前所述，利用MOD[23]和ASO[52]进行隐写/隐写分析时，游戏模拟的概念已经存在，但是利用神经网络进行实现和优化变得更加容易。</p>
<p>从2017年开始，经过5年的停滞，由于深度学习和GAN方法的出现，模拟游戏的概念在隐写术/隐写分析领域再次被研究。在2018年底,我们可以定义方法的四组或四类其中一些可能会合并</p>
<p>•生成类</p>
<p>•生成修改概率映射类</p>
<p>•基于GAN的对抗嵌入类(方法误导判别)</p>
<p>•3人游戏类</p>
<h3 id="生成类"><a href="#生成类" class="headerlink" title="生成类"></a>生成类</h3><p>第一个方法的基础上,通过GAN[29]生成器图像合成提出了cover图片生成,然后使用它们插入,修改。因此，这些早期的主张是通过修改来实现的。支持这种方法的理由是，生成的基础将更安全。一个经常被引用的参考文献是在ArXiv上发现的SGAN[92]，它在ICLR2017年被拒绝，随后从未发表。这篇未发表的论文有很多言外之意和错误。我们更倾向于参考2017年9月发表的SSGAN[83]，它提出了同样的建议:生成图像，然后在其中隐藏信息。不管怎样，这个协议似乎把事情复杂化了。Alice自己选择自然安全的嵌入的图像更合理,即图像无关痛痒,从未传播,适应内容,有很多的噪音或纹理[82],无法被分类器[51]很好的分类或小偏移系数[79],而不是生成图像,然后利用它们隐藏消息。</p>
<p>使用合成的一个更有趣的方法是直接生成stego图像。据我所知，Hu等人于2018年7月发表的文章中提出了第一种利用不修改[27]的隐写术原理，利用GAN机制进行图像合成的方法。 </p>
<p>第一步是学习一个网络来合成图像。本文利用GAN方法，利用DCGAN发生器[76]对图像进行初步的学习合成。因此，当输入在[-1,1]中均匀分布的固定大小的向量时，发生器合成图像。第二步是向另一个网络学习，从合成图像中提取矢量;提取的矢量必须与合成图像的发生器输入端给出的矢量一致。最后，最后一步是将提取的网络发送给Bob。现在，Alice可以将信息映射到一个固定大小的均匀分布向量，然后合成给定向量的图像，并将其发送给Bob。Bob可以提取向量并检索相应的消息。</p>
<p>多年没有修改的方法，其中一个问题是可以通信的比特数比修改过的方法要少。也就是说，修改和不修改方法之间的差距开始缩小。</p>
<p>这里快速分析一下这种方法的效率。Hu等人的论文[41]的容量约为0.018位/像素(bpp)，图像64×64。在实验中，合成的图像要么是人脸，要么是食物照片。Hill这样的算法<a href="BOSS数据库上其中一个最强大的算法[82]">57</a>是检测到SRNet<a href="一个最成功的隐写分析方法到2018年底">9</a>的误差概率Pe=31.3%(注意,Pe=50%相当于随机检测器)在256×256的BOSSBase0.1<br>bpp的有效载荷的大小。根据平方根定律，64×64 BOSS数据库的Pe更高。</p>
<p>因此约0.02 bpp的不修改的合成方法Hu et al。[41]的安全还没有足够的评估,对0.1bpp左右HILL,只有不到三分之一的机会被发现的clarivoyant隐写分析即一个实验室隐写分析(对比现实世界的隐写分析[44])。因此在无修改基于合成的方法之间仍然有边界比特传输,如胡等人的方法[41],和修改方法如S-UNIWARD[39], HILL[57],MiPod[79]甚至Synch-Hill[19],但这边界会减少。此外，请注意，仍然有一些问题需要解决，以确保像Hu等人提出的方法是完全安全的。特别是必须确保合成图像的检测[75]在长期内不会危及通信通道。还必须确保没有密钥不会危及这种方法。实际上，如果考虑到生成器是公共的，是否可以使用这些信息来推断使用了不经过修改的合成方法。</p>
<h3 id="生成修改概率映射类"><a href="#生成修改概率映射类" class="headerlink" title="生成修改概率映射类"></a>生成修改概率映射类</h3><p>2018年底，ASD-GAN[90]和UT-6HPF-GAN[98]两篇论文对生成的修改概率映射类进行了总结。在该方法中，有一个生成网络和一个判别网络。生成器网络从一个cover生成一个映射，称为修改概率映射。然后将这个修改概率映射传递给STC[24]模拟器中使用的随机绘制函数。然后我们获得一个值属于{-1,0，+1}的映射。这个映射称为修改映射，它对应于所谓的隐写噪声。鉴别网络的输入是一个cover或由stego的和(点对点和)和发生器产生的隐写噪声产生的图像。鉴别器的目的是区分cover和“cover+stego-noise”图像。该算法的目标是生成一个修改图，最大限度地误导鉴别器。当然，生成器被迫生成一个非零概率图，方法是在损失项中加上一个限制有效载荷大小的项，加上一个误导鉴别器的项。</p>
<p>在实践中,采用最新方法UT-6HPF-GAN[98],发电机是一种U-Net网络,画出函数可微函数获得的双层双曲正切,判别是Xu-Net[95]富含6种高通滤波器的预处理精神一样Ye-Net[99]或Yedroudj-Net[101]。 </p>
<p>系统先在一个数据库上学习，然后在256×256 BOSS数据库上进行安全比较。目前，即使该方法是有希望的，但实验中并没有使用STC来嵌入真实的消息，也无法证明所得到的修改概率映射是有意义的。目前，还不能保证所获得的概率映射在实际应用中能够超越HILL或SUNIWARD的STC安全性能。也不清楚生成器的损失是否必须集成与安全性相关的项和有效负载大小的项。通常，这两个标准之一是固定的，因此我们只需处于有效负载限制的发送方场景或安全限制的发送方场景。此外，还不能完全确定是否存在对生成器造成影响的失配现象(生成器在部署期间使用的学习数据库和数据库可能不同)。不管怎样，这是一个很有前途的类。</p>
<h3 id="基于GAN的对抗嵌入类"><a href="#基于GAN的对抗嵌入类" class="headerlink" title="基于GAN的对抗嵌入类"></a>基于GAN的对抗嵌入类</h3><p>基于GAN的对抗嵌入类重新使用了游戏模拟的概念，该概念在第1.6节的开头已经介绍过，由于只有两个玩家:Alice-agent和eve-agent，所以对问题进行了简化。历史上MOD[23]和ASO[52]是这类的第一个算法。</p>
<p>最近，一些论文通过生成一个愚蠢的例子(参见example[108])来使用对抗性概念，但这些方法并不是GAN的对抗性攻击。这些方法不是动态的，没有游戏模拟，它们不试图达到纳什均衡，它们不使用GAN模拟，在嵌入器和提取器之间没有学习交替。</p>
<p>有一篇论文更符合游戏模拟的精神，它采用了ASO[52]的原理，目标是更新成代价映射，它的算法是ADV-EMB<a href="之前在ArXivArXiv:1803.09043上命名为AMA">89</a>。在这篇文章中，作者建议通过让Alice-agent访问eve-agent丢失的梯度(类似于ASO，其中Alice-agent可以访问其Oracle(eve-agent))，用GAN实现一个嵌入逆。在adve-emb中，Alice-agent使用指向类边界(cover和stego之间)方向的梯度来修改成本地图，而在ASO中，Alice-agent直接使用指向类边界的方向来修改成代价映射。</p>
<p>在ADV-EMB[89]中，代价映射是用SUNIWARD的代价进行初始化的(对于ASO，它是HUGO的成本[69])。在迭代过程中,代价映射更新,但只有一个β的百分比值更新。ADV-EMB迭代停止时,映射由β−1%的位置有一个代价定义为S-UNIWARD和β的位置有一个代价来自S-UNIWARD的初始成本的变化。</p>
<p>注意，更新代价会导致代价不对称，因为在ASO中，a +1更改的代价不再等于a-1更改的代价。此外，一个像素的两个代价的更新是相当粗糙的，因为它是一个方向上简单的除以2(+1或-1)和另一个方向上简单的乘以2。对于给定的像素，通过选择cover标签来计算损耗的梯度符号，可以确定两个方向(+1/-1)是否应该降低或增加代价。这个想法就像在ASO，欺骗区别，因为当一个人决定降低一个代价的价值时，它是倾向于修改与这个代价相关的方向，因此我们促进更接近cover类。</p>
<p>有了这样一个方案，安全性得到了提高。对初始代价映射的修改很少，这一事实可能使得保留初始嵌入方法成为可能，从而避免引入太多可能被另一个隐写分析者[47]检测到踪迹。也就是说，更新的代价可能要细化到更好的考虑梯度值。这种方法应该允许选择将被修改的像素，最终通过查看它们的初始成本。最后，就像ASO的情况一样，如果鉴别器没有足够的能力进行隐写分析，那么对于Alice-agent来说，它可能完全起反作用。因此，关于收敛准则、停止准则、Alice-agent与Eve-agent交替的迭代次数、衡量Eve-agent之间相关性的度量标准的定义等问题还存在许多未解决的问题。</p>
<p><img src="/2019/10/10/DL-stganography-summarize-2015-2018/7fbfe92e205781af7e0f63676a13d492.png" alt=""></p>
<h3 id="三人游戏类"><a href="#三人游戏类" class="headerlink" title="三人游戏类"></a>三人游戏类</h3><p>3人游戏的概念是前一个类的延伸(参见基于GAN的“对抗嵌入”类)。在那里，有三个代理:Alice-agent、Bob-agent和eve-agent(参见1.6节回忆游戏)。注意，Alice-agent和bob<br>-agent是“链接的”，因为bob-agent只在Alice-agent获得的解决方案上添加约束。因此，主要的“博弈”是Alice-agent和eve-agent之间的对抗博弈(或对抗性博弈)，而Alice-agent和Bob-agent之间的“博弈”具有很强的合作性，因为这两个agent具有通信的共同目的(Alice-agent和Bob-agent都希望Bob-agent能够无差错地提取消息)。图1.3从[102]总结了3人游戏家族的原则。Alice-agent获取一个cover图像、一条消息和一个密钥，然后经过一个离散化步骤生成一个密钥图像。Bob-agent使用这个stego映像来检索消息。在另一方面，每个代理必须决定一个图像是cover还是stego;这个代理输出一个分数。</p>
<p>从历史上看，在MOD和ASO之后，我们可以看到2016年的Abadi和Andersen[1]的论文中提出了三名玩家的想法的前提。在这篇论文中，来自谷歌Brain的Abadi和Andersen[1]提出了一个基于三种神经网络的加密的玩具样例。神经网络的使用，使其易于获得战略平衡，因为该问题被表示为一个最小-最大问题，其优化可以通过反向传播过程进行。当然，这个3人游戏的概念可以通过使用深度学习来转换为隐写术。</p>
<p>2017年12月(GSIVAT;[31])和2018年9月(HiDDeN;[109])，来自机器学习社区的两个不同团队分别在NIPS的2017年和ECCV的2018年提出，利用3个不断更新的CNNs实现战略嵌入，这3个CNNs分别扮演Alice-agent、bob-agent和eve-agent的角色。这两篇文章超越了三人游戏的概念，他们的断言是错误的，主要是因为安全的概念及其评估没有得到正确的处理。如果一个人把自己放在标准框架中来评估嵌入算法的经验安全性，也就是说用一个透视的Eve，这两种方法都是可以检测到的。这两篇论文的重要问题是首先，这两种方法都没有使用密码键;它相当于总是使用相同的密钥,这导致非常可检测方案[72],第二,没有从Alice-agent离散的像素值,第三,计算复杂度由于完全连接块的使用导致不实际方法,第四,安全评价与先进的隐写分析对比尚未完成。</p>
<p>在2019年初，Yedroudj等[102]重新定义了3-player的概念，整合了使用stego-key的可能性，处理离散化的问题，通过卷积模块得到一个可扩展的解决方案，并使用一个合适的隐写分析者。这个命题不能与经典的自适应嵌入方法相比，但是这种方法确实有潜力。该算法的误码率小到可以忽略，在纹理部分进行了嵌入，在以后的工作中可以进一步提高其安全性。例如，Yedroudj-Net[101]的隐写分析，在等于误差之前，来自BOWS2数据库的图像的实际有效载荷大小0,3bpp的错误概率是10,8%。例如，这可以与WOW[40]在相同条件下的隐写分析进行比较，后者给出的错误概率为22.4%。仍然存在安全缺口，但这种方法为许多研究铺平了道路。关于Alice-agent和Bob-agent之间的连接、GANs的使用、损失的定义以及不同约束之间折衷的调优，仍然存在一些问题。 </p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在这本书的这一章中，我们实际上已经完成了自2015年隐写术和隐写分析的深度学习这一主题的完整呈现。作为一名在此期间审阅了大量与这一主题相关的论文的人，我认为，我希望这一章能够帮助社区更好地理解已经做了什么，以及接下来要处理什么。在这一章中，我们回顾了CNN的主要组成部分。我们讨论了内存复杂度、时间复杂度和效率方面的实际问题。我们已经用一些过去的方法做了链接，这些方法与CNN目前的做法相似。我们已经介绍了2019年初之前的各种主要网络，以及多种场景，最后我们列举了最近使用GANs进行隐写术的方法。正如本章所回忆的，很多事情还没有解决，最主要的是能够玩更多的现实主义假设，更“自然”。“圣杯”是cover失配和stego失配，但在某种程度上，失配是所有机器学习社区共同面临的问题。CNNs现在在隐写分析社区中已经很好地存在了，下一个问题可能是:如何更进一步，产生更聪明的网络?</p>

      
    </div>
    
    
    

    

      <div>
        
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
        
      </div>

      
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Steganography/" rel="tag"><i class="fa fa-tag"></i> Steganography</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/29/A-Survey-of-Image-Information-Hiding-Algorithms-Based-on-DeepLearning-2018-CR3/" rel="next" title="A Survey of Image Information Hiding Algorithms Based on Deep Learning(2018,CR3)">
                <i class="fa fa-chevron-left"></i> A Survey of Image Information Hiding Algorithms Based on Deep Learning(2018,CR3)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/02/GAN/" rel="prev" title="GAN">
                GAN <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  <div onclick="showGitment()" id="gitment_title" class="gitment_title">显示 Gitment 评论</div>
  <div id="container" style="display:none"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
  const myTheme = {
  render(state, instance) {
  const container = document.createElement('div');
  container.lang = "en-US";
    container.className = 'gitment-container gitment-root-container';
   container.appendChild(instance.renderHeader(state, instance));
    container.appendChild(instance.renderEditor(state, instance));
    container.appendChild(instance.renderComments(state, instance));
    container.appendChild(instance.renderFooter(state, instance));
    return container;
    }
}
function showGitment() {
$("#gitment_title").attr("style", "display:none");
$("#container").attr("style", "").addClass("gitment_container");
var gitment = new Gitment({
id: window.location.pathname,
theme: myTheme,
owner: '',
repo: '',
oauth: {
client_id: '9f634ff1d663061b7b31',
client_secret: '45166540e0b361ee1919e27f29ad9aac978d8437'
}
});
gitment.render('container');
}
</script>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/jiansheng.jpg"
               alt="Wu Tian" />
          <p class="site-author-name" itemprop="name">Wu Tian</p>
           
              <p class="site-description motion-element" itemprop="description">Record</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fennudehaogua" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://mail.google.com/mail/u/0/?tab=wm#inbox" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/profile.php?id=100017135643802" target="_blank" title="FB Page">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                    
                      FB Page
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.youtube.com/channel/UC8TkFUpWAS2wzj34ijgAZGA?view_as=subscriber" target="_blank" title="YouTube">
                  
                    <i class="fa fa-fw fa-youtube"></i>
                  
                    
                      YouTube
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.ws.binghamton.edu/fridrich/?tdsourcetag=s_pctim_aiomsg" title="Fridrich" target="_blank">Fridrich</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://imkira.com/" title="Kira" target="_blank">Kira</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Deep-Learning-in-steganography-and-steganalysis-from-2015-to-2018"><span class="nav-number">1.</span> <span class="nav-text">Deep Learning in steganography and steganalysis from 2015 to 2018</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#摘要"><span class="nav-number">2.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#隐写术与隐写分析中的深度学习"><span class="nav-number">3.</span> <span class="nav-text">隐写术与隐写分析中的深度学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一个深度神经网络的构建模块"><span class="nav-number">3.1.</span> <span class="nav-text">一个深度神经网络的构建模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#卷积神经网络的整体视图"><span class="nav-number">3.1.1.</span> <span class="nav-text">卷积神经网络的整体视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预处理模块"><span class="nav-number">3.1.2.</span> <span class="nav-text">预处理模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#卷积模块"><span class="nav-number">3.1.3.</span> <span class="nav-text">卷积模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分类模块"><span class="nav-number">3.1.4.</span> <span class="nav-text">分类模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#卷积模块的不同步骤"><span class="nav-number">3.2.</span> <span class="nav-text">卷积模块的不同步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#卷积"><span class="nav-number">3.2.1.</span> <span class="nav-text">卷积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#激活"><span class="nav-number">3.2.2.</span> <span class="nav-text">激活</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#池化"><span class="nav-number">3.2.3.</span> <span class="nav-text">池化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归一化"><span class="nav-number">3.2.4.</span> <span class="nav-text">归一化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存-时间复杂度和效率"><span class="nav-number">3.2.5.</span> <span class="nav-text">内存/时间复杂度和效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深度学习和过去方法的联系"><span class="nav-number">3.2.6.</span> <span class="nav-text">深度学习和过去方法的联系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2015-2018年期间使用的不同网络"><span class="nav-number">3.3.</span> <span class="nav-text">2015 - 2018年期间使用的不同网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无边信息的空域隐写分析"><span class="nav-number">3.3.1.</span> <span class="nav-text">无边信息的空域隐写分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#边信息已知的空域隐写分析"><span class="nav-number">3.3.2.</span> <span class="nav-text">边信息已知的空域隐写分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JEPG隐写分析"><span class="nav-number">3.3.3.</span> <span class="nav-text">JEPG隐写分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于失配现象场景的讨论"><span class="nav-number">3.3.4.</span> <span class="nav-text">关于失配现象场景的讨论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于GAN的隐写"><span class="nav-number">3.4.</span> <span class="nav-text">基于GAN的隐写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成类"><span class="nav-number">3.4.1.</span> <span class="nav-text">生成类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成修改概率映射类"><span class="nav-number">3.4.2.</span> <span class="nav-text">生成修改概率映射类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于GAN的对抗嵌入类"><span class="nav-number">3.4.3.</span> <span class="nav-text">基于GAN的对抗嵌入类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三人游戏类"><span class="nav-number">3.4.4.</span> <span class="nav-text">三人游戏类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结论"><span class="nav-number">4.</span> <span class="nav-text">结论</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wu Tian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  


<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"mobile":{"show":false},"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/assets/haruto.model.json"}});</script></body>
</html>
